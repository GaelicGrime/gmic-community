#@gui Pseudo-ECB (Electronic Code Book Algorithm): pseudo_ecb, _pseudo_ecb_preview(0)
#@gui : note = note("This filter is inspired by one of the glitch plugin for Paint.NET. This doesn't actually emulate how the codebook encryption algorithm actually work, but it is inspired from it.  This filter uses bomb blending mode which involves RGBA Transfer Function Mesh. See Mesh Blend filter for a link. \n\n <u>Note that the filter works best on images with large patches of single colors.</u> ")
#@gui : sep = separator()
#@gui : note = note("<b>Color Space Choice</b> \n\n <i>Keep in mind that you may not necessarily get what you imagine. Just treat these as themes. </i>")
#@gui : Colour Space = choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : sep = separator()
#@gui : note = note("<b>Final Color Processing</b> \n\n <i>This refers to the how the colors are going to be processed. If you find that there's too little difference in hues or chroma or luminosity in local areas, this should be on. Sometimes, the result are better without the final processing.</i>")
#@gui : Equalize Filter = bool(0)
#@gui : Pseudo-Coloring = bool(1)
#@gui : Tonality Blend = choice(20,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Tonality Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Pattern Key Generator</b>")
#@gui : Double Gradient? = bool(1)
#@gui : Length of Gradient#1 = float(5,0,32)
#@gui : ECB Gradient#1 Angle = float(0,0,360)
#@gui : ECB Inversion#1 = bool(0)
#@gui : Length of Gradient#2 = float(5,0,32)
#@gui : ECB Gradient#2 Angle = float(90,0,360)
#@gui : ECB Inversion#2 = bool(0)
#@gui : Gradient Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Gradient Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Sharpen Filtering</b>")
#@gui : Sharpening Noise Processing = float(15,0,200)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Image Processing</b>")
#@gui : Transfer Mesh Size for Image (Squared) = int(256,2,256)
#@gui : Image Mesh Contrast = int(75,25,100)
#@gui : Transfer Mesh Size for Gradient (Squared) = int(16,2,256)
#@gui : Gradient Mesh Contrast = int(100,25,100)
#@gui : Double Encryption Effect = bool(1)
#@gui : Inner Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Inner Blend Opacity = float(1,0,1)
#@gui : Outer Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Outer Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Self-Image Post-Processing</b> \n\n <i>This invokes a self-blending operation after the main pseudo-ecb has been generated with different blend mode.</i>")
#@gui : Activate Self-Image Post-Processing = bool(1)
#@gui : Equalize ECB Processing = bool(0)
#@gui : Pseudo-Coloring = bool(1)
#@gui : Self-Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Self-Blend Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<b>Multilayer processing</b>\n\n<small><b>Warning:</b>All layer must be of same size for expected result!</small>"), Apply to all layers? = bool(0)
#@gui : Boundary Condition = choice(0,"Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/12/30</i>.</small>")
pseudo_ecb:
ww={w+4}
hh={h+4}
total_image_minus_one={$!-1}
if $total_image_minus_one&&$30 expand_xy 4,$31 a x _pseudo_ecb ${1-29} s x,{$total_image_minus_one+1} shrink_xy 4 rv
else _pseudo_ecb ${1-29} fi
_pseudo_ecb:
csswap $1,0
repeat $! l[$>]
repeat {$20+1}
pseudo_ecb_generate ${2-19},${21-29}
done
endl
csswap 0,$1
done

pseudo_ecb_generate:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
+ac "ecb_gradient_base[0] $6,$7,$8",rgb
if {$2==1} _pseudo_c[1] fi
local[1]
if {$5==1} +ac "ecb_gradient_base[0] $9,$10,$11",rgb
_pseudo_c[1]
blend ${_mode{$12+1}},$13 if {$1==1} equalize fi fi
endlocal
local[0]
sharpen $14
if {$2==1} +_pseudo_c[0]
elif {$2==1} [0] fi
+fx_blend_bomb[0] 0,1,$15,$15,0,0,$16,0,0,0,1,0
blend ${_mode{$19+1}},$20
endlocal
fx_blend_bomb[1] 0,1,$17,$17,0,0,$18,0,0,0,0,0
if {$1==1} equalize[1] fi
blend ${_mode{$21+1}},$22
if {$1==1} +equalize blend ${_mode{$3+1}},$4 fi
if {$1==0} [0] blend ${_mode{$3+1}},$4 fi
if {$23==1} [0] if {$24==1} equalize[1] fi if {$25==1} _pseudo_c[1] fi blend ${_mode{$26+1}},$27
fi

ecb_gradient_base:
f "ang=pi*$2/180;G=x*cos(ang)+y*sin(ang);G%$1" n 0,255
if {$3==1} mul -1 abs fi

_pseudo_c : v - if {s!=1} to_gray. fi {max(1,round(iM,1,1))},1,1,3,u(255) round. map.. . rm.  v +

_pseudo_ecb_preview :
gui_split_preview "pseudo_ecb $*",${-3--1}
