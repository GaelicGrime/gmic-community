#@gmic
#
#  File        : karsten_rodenacker.gmic
#                ( G'MIC and G'MIC-Gimp commands file )
#
#  Description : Define several gmic commands
#
#  Copyright   : Karsten Rodenacker
#
#  License     : CeCILL v2.0
#                ( http://cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#@gui _<b>Testing</b>
#@gui KaRo's Tests

#@gui About : _none_, karos_about
#@gui : note = note{"KaRo's test files for <b>G'MIC</b>\n\written by"}
#@gui : note = link("Karsten Rodenacker","http://K.Rodenacker.de")
#@gui : note = note{"\n"}
#@gui : note = note{"The source code of this set of filters is available at :"}
#@gui : note = link("https://github.com/dtschump/gmic-community/blob/master/karsten_rodenacker.gmic")
#@gui : sep = separator()
#@gui : note = note{"Several operations here rely on executables existing <i>in search PATH</i> ($PATH unter Mac/Unix).
#@gui : This means that the executable is downloaded or built and properly located.
#@gui : E. g. CImg examples have to be built and copied to a location in the search path, \
# e.g. under unix <i>/usr/local/bin</i>.
#@gui : Similar with PINK executables. For Mac they have to be built according the README with <i>./makelin</i>
#@gui : and PATH as to be extended by <i>..pink location../linux/bin</i>."}
#@gui : sep = separator()
#@gui : note = note{"  CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_skeleton.cpp")
#@gui : note = note{"  CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_nlmeans.cpp")
#@gui : note = note{"  mM Differences: \nmathematical morphology operation differences\n\
# mM operation size - mM operation size2"}
#@gui : note = note{"  oC Differences: \nmathematical morphology open/close differences\nmM open size - mM close size"}
#@gui : note = note{"  Pink operations binary: <i>Pink applications</i> in search PATH"}
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/index.html")
#@gui : sep = separator()
#@gui : note = note{"\nThe functions defined are quite <i>experimental</i> and subject to changes.
#@gui : Please do not rely on the fact that they will perform equally forever."}
karos_about : 
  if $_version<270 osteo gui_print_preview "G'MIC version "$_version,32,"KaRo's tests",22
# some poor replacement of missing fx_logo!
# fx_logo_version{round(u(0.5,3.49))} $_version
  else
    if {$!==0} osteo r. 400,400,1,3 fi
    [0] *. 0
    text. "g'mic",0.5~,0.15~,36,1,255,255,0
    text. "\n\nversion "$_version,0.5~,0.2~,18,1,255,255,0
    text. "KaRo's",0.5~,0.4~,57,1,255,0,255
    text. "Tests",0.5~,0.6~,57,1,200,0,200
    +to_gray. skeleton. , n[-1--2] 0,255 dilate.. 2 -[-1--2] + n 0,255
  fi

#@cli karos_error : "message"
#@cli : Message in karos_about image for gui
karos_error : 
  karos_about
	text. "${1=Error}",0.5~,0.8~,36,1,200,0,200

#------------------------------------
#
#@cli :: PINK-library operators
#
#------------------------------------

_wrbytepnk :
  output_pink3d ${1}.pnk

#@cli _xpink : pink_cmd, p1, ... , pn
#@cli : Packs the list of parameters to a string with spaces, \
# generates the pink input image in tmp, executes the pink command \
# and reads the result image. 
#@cli : To see the parameters and to control the existence of the program, \
# type in a system shell 'pink_cmd', e.g. $ asf !
#@cli : If $GMIC_PINK_VERBOSE is true, the command and sysout is printed
#@cli : If $GMIC_PINK_NO_RM is true, the temporary files are not removed
#@cli : Outfiles with P == 80 as first char are considerd as images, everything else is considered as list
_xpink : 
  na={-1,n}
  filename=${-file_rand}
  x_filename={/$filename}
  if {if(isnum($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0} verb=" 2>&1" else verb=" >/dev/null 2>&1" fi
  if {if(isnum($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
  prefix=pink. suffix=""
  if {!${-is_windows}}
    -x "which "${prefix}${1}$verb
    if {${}!=0} prefix=""
      -x "which "$1$verb
      if {${}!=0} suffix=".exe"
        -x "which "$1$suffix$verb
        if {${}!=0} v + error "Executable (pink.)"$1" not found in PATH, status = "${}"!! Returning!!\n" v - fi
      fi
    fi
    if {if(isnum($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0}
		  echo_stdout ${prefix}${1}${suffix}" "${filename}".pnk $2 "${filename}"_o.pnk"$verb fi
    o ${filename}.pnk x ${prefix}${1}${suffix}" "${filename}".pnk ${2} "${filename}"_o.pnk"$verb
    _status=${}
  else
    if {if(isnum($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0}
		  echo_stdout $1" "${x_filename}".pnk $2 "${x_filename}"_o.pnk" fi
    o ${filename}.pnk x ${1}" "${x_filename}".pnk ${2} "${x_filename}"_o.pnk"
    _status=${}
  fi
  if {!$no_rm} file_rm ${x_filename}.pnk fi
  if {$_status!=0" && "['"$1"']!='seuilauto'} error "Exec status is "$_status"." 
  elif isfile(['{/${filename}_o.pnk}'])
    input_pinktest ${filename}_o.pnk
    if {${}==80} i ${filename}_o.pnk
    else input_pinklist ${filename}_o.pnk fi
    k. nm. $na
    if {!$no_rm} file_rm ${x_filename}_o.pnk fi
  else error "Exec error "$_status"!!"
  fi 

#@cli _xpinks : pink_cmd,parameter_string(with spaces)
#@cli : Splits c channel if necessary and executes "_xpink pink_cmd,parameter_string" to each image
_xpinks : v -
  s={s} if {$s>1} s. c fi
  repeat $! l[$>]  _xpink $1,"$2" k. endl done
  if {$s>1} a[-$s--1] c fi v +

_xframe :
  line 0%,0%,100%,0% line 0%,100%,100%,100% line 0%,0%,0%,100% line 100%,0%,100%,100%

#@cli karo_frame : _width(1), _border(0)
#@cli : _width thickness of border
#@cli : _border==false border is deleted, inner region copied
#@cli : _border==true border is copied, inner region deleted
karo_frame :
  if ${2=0} e[^2] "Copy border Delete inner." f bb=${1=1};if(x<bb||y<bb||x>(w-bb-1)||y>(h-bb-1),i,0);
	else  e[^2] "Delete border Copy inner." f bb=${1=1};if(x<bb||y<bb||x>(w-bb-1)||y>(h-bb-1),0,i); fi

#@cli output_pink3d : filename,_type
#@cli : Save selected images as _type-coded (P5,P8,P9) PNK files (PINK extension for 3d volumetric images).
output_pink3d : skip ${2=P5}
  e[^-1] "Output image$? as file '$1' (in 3d pink extension of "$2"-coded PNK format)."
  v - if {$!==1} filename0="$1"
  else repeat $! filename$>=${filename\ "\"$1\"",$>} done
  fi
	tp="$2"
  repeat $! l[$>]
    if {['$tp']=='P5'&&iM>=256} tp="P8" fi
    if {['$tp']=='P5'} o. pnk:${filename$>},uchar
# #        ({'P5\n\#origin {w/2} {h/2}\n{w}\ {h}\ {d}\n255\n'})
# #        header="P5\n#origin "{w/2}" "{h/2}"\n"{w}" "{h}" "{d}"\n255\n"
#       if {d==1} ({'P5\n{w}\ {h}\n255\n'}) else ({'P5\n{w}\ {h}\ {d}\n255\n'}) fi
#       +channels.. 0 y. x a[-2,-1] x
    elif {['$tp']=='P8'} o. pnk:${filename$>},uint
#       ({'P8\n{w}\ {h}\ {d}\n{iM}\n'})
#       +channels.. 0 cast. uint,uchar y[-2,-1] x a[-2,-1] x
    elif {['$tp']=='P9'} o. pnk:${filename$>},float
#       ({'P9\n{w}\ {h}\ {d}\n{ceil(iM)}\n'})
#       +channels.. 0 cast. float,uchar y[-2,-1] x a[-2,-1] x
    else error "Type $tp not implemented!" fi
#    o. raw:${filename$>},uchar
#    rm.
  endl done v +

#@cli input_pinktest : file_name
#@cli : Test file type
#@cli : returns the first character from the first non comment line in status
#@cli : P == 80 ! everything else is considered as list
input_pinktest : 
  i[0] raw:"$1",uchar s[0] -,10 i=0
  do u {$i,@0} while {${}==35&&i++<$!}
	rm

_pink_setorigin : skip "${2=0} ${3=0} ${4=0}" v -
  i[0] raw:"$1",uchar s[0] +,10
	i. "$1"
	ln="\n#origin "{round(w*($2+1)/2)}" "{round(h*($3+1)/2)}
	if {d>1} ln=${ln}" "{round(d*($4+1)/2)} fi
	({'$ln'}) l. s x a y endl mv. 1 rm. y x a x
	o. raw:"$1",uchar v +

#@cli input_pinklist : file_name, _mode
#@cli : Read a pink list file
#@cli : spec. type G from pink.delaunay) at file_name and prepare
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
input_pinklist :
  skip ${2=0}
  e[^-1] "Read pinklist $1"
  i[0] raw:"$1",uchar s[0] -,10
  if {{0,@0}=={'G'}}  e "Delaunay graph list file" 
    rows[0] 2,100% n={{0,t}} rm[0]
    3,$n,1,1 nm. vertices
    1,$n,1,1 nm. vhull
    0 nm. edges
    repeat {$!-3} l[{$>},vertices,vhull,edges]
      s[0] -,32
      =[vertices] {0,t},0,$> =[vertices] {1,t},1,$> =[vertices] {2,t},2,$>
      =[vhull] {3,t},0,$> {{4,t}*3},1,1,1 p=$>
      repeat {4,t} =. 2,{$>*3} =. $p,{$>*3+1} =. {{$>+5},t},{$>*3+2} done
      a[edges] .,x rm[1-4,-1]
    endl done
    k[vhull,vertices,edges] mv[vhull] 0
    ver={vertices,h}
    edg={edges,{w/3}}
    nhull={vhull,is}
    if {$2==0}
      if {vhull,is} repeat {vertices,h}
        if {vhull,@{$>}} (1,$>) a[edges] .,x rm. edg+=1 fi
      done fi
      ({'CImg3d'}) mv. -3
      ($ver,$edg) mv. -3
      (255^255^255) r. {$edg-$nhull}
      (0,0,255) .x{$nhull-1} a[-1--$nhull] x
      (0.6) r. {$edg-$nhull}
      (1) .x{$nhull-1} a[-1--$nhull] x
      unroll y a[-1--8] y rm..
    else
      $ver,$ver
      repeat {{edges,w}/3}
        =. 1,{edges,@{$>*3+1}},{edges,@{$>*3+2}}
      done
    fi
    u $ver,$edg,$nhull
  elif  {{0,@0}=={'e'}} e "1d list file" 
    s[0] -,32 n={{1,t}} rm[0,1]
    1,$n,1,1 nm. vertices
    if {$!-1<$n} s[0] -,32 fi
    repeat {$!-1} l[{$>},vertices]
      =[vertices] {0,t},0,$>
    endl done
    k[vertices]
    ver={vertices,h}
    u $ver
  elif  {{0,@0}=={'s'}} e "1d vertice list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    1,$n,1,1 nm. vertices
    1,$n,1,1 nm. vhull
    repeat {$!-2} l[{$>},vertices,vhull]
      s[0] -,32
      =[vertices] {0,t},0,$>
			=[vhull] {1,t},0,$>
    endl done
    k[vertices,vhull] a x
    ver={vertices,h}
    u $ver
  elif  {{0,@0}=={'b'}} e "2d list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    2,$n,1,1 nm. vertices
    repeat {$!-1} l[{$>},vertices]
      s[0] -,32
      =[vertices] {0,t},0,$>  =[vertices] {1,t},1,$>
    endl done
    k[vertices]
    ver={vertices,h}
    u $ver
  elif  {{0,@0}=={'n'}} e "2d vertice list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    2,$n,1,1 nm. vertices
    1,$n,1,1 nm. vhull
    repeat {$!-2} l[{$>},vertices,vhull]
      s[0] -,32
      =[vertices] {0,t},0,$>  =[vertices] {1,t},1,$>
			=[vhull] {2,t},0,$>
    endl done
    k[vertices,vhull] a x
    ver={vertices,h}
    u $ver
  elif  {{0,@0}=={'B'}} e "3d list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    3,$n,1,1 nm. vertices
    repeat {$!-1} l[{$>},vertices]
      s[0] -,32
      =[vertices] {0,t},0,$> =[vertices] {1,t},1,$> =[vertices] {2,t},2,$>
    endl done
    k[vertices]
    ver={vertices,h}
    u $ver
  elif  {{0,@0}=={'N'}} e "3d vertice list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    3,$n,1,1 nm. vertices
    1,$n,1,1 nm. vhull
    repeat {$!-2} l[{$>},vertices,vhull]
      s[0] -,32
      =[vertices] {0,t},0,$> =[vertices] {1,t},1,$> =[vertices] {2,t},2,$>
			=[vhull] {3,t},0,$>
    endl done
    k[vertices,vhull] a x
    ver={vertices,h}
    u $ver
  else error "Not implemented!" fi

#@cli pink : eq. to 'pink_new'. :
pink : pink_new $*

#@cli pink_new : pink_cmd,p1,...,pn
#@cli : Pink wrapper (requires the PINK library to be installed), see 
#@cli :   <A href="https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/">Pink</A>
#@cli : Shortcut 'pink'
#@cli : Prepares input, calls external "pink_cmd input p1...pn output" and reads output (/tmp) \
# and replaces positional image parameters bei temp. files. \
# Only Pink routines with input file(s) and ONE output file can be called. \
# Images with spectral channels (s>1) are splitted, processed one by one and merged.\n
#@cli : ATTENTION positional image parameter are never spitted and merged \
# similar to selected (input) and output images. Positional image parameter should already have the \
# needed format for the selected pink binary!\n
#@cli : pink_new prepares selected images and image parameter as pnk files in 'auto' mode and \
# creates a command string. \
# Images (splitted if spectrum s > 1) are processed one by one and \
# are written as pnk files to temporary space, outfile is \
# a pnk file name pointing to temporary space too. The executed call looks like \
# "pink_cmd infile p1 ... (px)imagefile ... pn outfile".\n
#@cli : OS variable:
#@cli : GMIC_PINK_NO_RM == true: created files in temporary space are not removed
#@cli : GMIC_PINK_VERBOSE == true: created cmd string and pink messages are printed
#@cli : $ image.jpg +pink_new. asfr,5 pink_new.. asf,5
#@cli : $ image.jpg +blur 2 pink_new maxima,4
#@cli : $ sp ? to_gray ir. 0,50% +pink_new. distc,3 +negate.. +pink_new... dist,3 pink_new[1] \
# bisector,[0] pink_new[3] bisector,[2] k[1,3] a c
#@cli : $ sp 2 +pink_new. dilatballnum,5 +-
#@cli : $ sp boats ir. 0,50% +pink_new. dilatballnum,10 +pink_new.. distgeo,.,4
#@cli : $ sp barbara +pink_new. seuilauto,128,max,3
pink_new : 
  $=pp
  if {$#>1}
    np=""
    repeat {$#-1}
      if ${is_image_arg\ ${pp{$>+2}}}
			  pass${pp{$>+2}}
			  filename$>=${-file_rand}
				o. ${filename$>}.pnk rm.
			  np=${np}\ ${filename$>}.pnk
			else np=${np}\ ${pp{$>+2}} fi
    done
  else np=" " fi
  v + e[^1] "Call pink_new package on image$? with cmd: \"$1 [img]"$np" [img]\"." v -
  _xpinks[0] $1,$np
  if {if(isnum($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
	if {$no_rm==0} repeat {$#-1} strlen ${filename$>} if {${}>0} file_rm ${filename$>}.pnk fi done fi


# # #@cli pink : pink_cmd,p1,...,pn
# # #@cli : Abbreviaton of pink_new (obsolet, use pink_new !!)
# # #@cli : Pink wrapper (requires the PINK library to be installed).
# # #@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/)
# # #@cli : prepares input, calls external "pink_cmd input p1...pn output" and reads output (/tmp)
# # #@cli : $ image.jpg +pink asfr,5 pink[0] asf,5
# # #@cli : $ image.jpg +blur 2 pink maxima,4
# # #  v -
# # #  if {$#>1} ({"'${2--1}'"}) replace. {','},{"' '"} p={t} rm. else p=" " fi
# # #  v + e[^-1] "Call pink package on image$? with cmd: \"$1 [img] "$p" [img]\"." v -
# # #  repeat $! l[$>] _xpinks $1,$p endl done v +

#@cli pink_grayskel : _connectivity={ 4 }, _lambda=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/grayskel_8c.html)
#@cli : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'lambda=0'.
#@cli : $ image.jpg +pink_grayskel , +pink_grayskel[0] ,10 +pink_grayskel[0] ,100 append_tiles 2
pink_grayskel : skip ${1=4},${2=0}
  check "${1=4}==4" repeat $! l[$>] pink grayskel,null,$1,$2 endl done

#@cli pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightmaxima_8c.html)
#@cli : Heightmaxima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightmaxima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
  e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>] _xpink "heightmaxima","$1 $2" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightminima_8c.html)
#@cli : Heightminima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightminima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
  e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>] _xpink "heightminima","$1 $2" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkernu_8c.html)
#@cli : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg +pink_htkern ,u +pink_htkern[0] , +-[-1,-2] remove[0]
pink_htkern : skip ${1=4},${2=""} v -
  repeat $! l[$>] _xpinks htkern$2,"null $1" endl done v +

#@cli pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkernu_8c.html)
#@cli : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg pink_lvkern ,u
pink_lvkern : skip ${1=4},${2=""}
  check "${1=4}==4 || $1==8 || $1==6 || $1==26" v -
  repeat $! l[$>] _xpinks lvkern${2},"null $1" endl done v +

#@cli pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/minima_8c.html)
#@cli : Regional minima (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4'.
#@cli : $ image.jpg +blur 2 pink_reg_minima ,
pink_reg_minima : check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  e[^-1] "Compute regional minima exec with connectivity $1."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>]  _xpink "minima","$1" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelcurv_8c.html)
#@cli : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% {w},{h} fill[-1] 'if(x>w/2,255,0)' tp=${-path_tmp} output[-1] ${tp}/inhibit.pgm \
# remove[-1] +pink_skelcurv[0] , +pink_skelcurv[0] ,,${tp}/inhibit.pgm exec "rm "${tp}"/inhibit.pgm"
#@cli : $ image.jpg threshold 50% +pink_skelcurv , +pink_skelcurv[-2] ,8
pink_skelcurv : skip ${1=0},${2=4},${3=""}
  e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, \
connectivity=$2, inhibit=$3."
  v - repeat $! l[$>] _xpinks "skelcurv","$1 $2 $3" endl done v +

#@cli pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelend_8c.html)
#@cli : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points \
# (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'n=0'.
#@cli : $ image.jpg threshold 50% +pink_skelend , +pink_skelend[-2] ,-1
pink_skelend : skip ${1=4},${2=0}
  v - repeat $! l[$>] _xpinks "skelend","$1 $2" endl done v +

#@cli pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skeleton_8c.html)
#@cli : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skeleton[-1] ,
 pink_skeleton : skip ${1=0},${2=4},${3=""}
  v - repeat $! l[$>] _xpinks "skeleton","$1 $2 $3" endl done v +

#@cli pink_skelpar : _algorithm={0...29},_nsteps=_1,_inhibit=""
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelpar_8c.html)
#@cli : Parallel binary skeleton (requires the PINK library to be installed).
#@cli : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skelpar[-1] 0 +pink_skelpar[-1] 2
pink_skelpar : skip ${1=4},${2=-1},${3=""}
  v - repeat $! l[$>] _xframe _xpinks "skelpar","$1 $2 $3" endl done v +

#@cli pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/wshedtopo_8c.html)
#@cli : Watershed (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@cli : $ image.jpg +pink_wshed ,1,5 pink_wshed[0] ,,5
pink_wshed : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=0},${3=0}
  e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    if {d==1}
      check "${1=4}==4 || $1==8"
      repeat $! l[$>]
        f max(min(i,255),0)
        if {$2!=0} negate 255 fi
        if {$3>=0} pink heightminima,$1,$3 fi
        pink wshedtopo,$1
        if {$2!=0} negate 255 fi
      endl done
    else
      check "$1==6 || $1==26"
      repeat $! l[$>]
        f max(min(i,255),0)
        if {$2!=0} negate 255 fi
        if {$3>=0}
          pink heightminima,$1,$3
        fi
        pink wshedtopo,$1
        if {$2!=0} negate 255 fi
      endl done
    fi
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli output_pinklist : filename, _type
#@cli : write an (c,n) image with c=1, 2, 3, 4 colums and n lines to a pink list file
#@cli : Automatic type: c=1 => 'e', c=2 => 'b' c=3 => 'B', c=4 => 'N'
#@cli : Manual type possible: c=2 => 's', c=3 => 'n'
#@cli : List formats according PINK
#@cli :   e <n>       s <n>         b <n>         n <n>            B <n>            N <n>
#@cli :   x1          x1 v1         x1 y1         x1 y1 v1         x1 y1 z1         x1 y1 z1 v1
#@cli :   x2    or    x2 v2   or    x2 y2   or    x2 y2 v2   or    x2 y2 z2   or    z2 x2 y2 v2
#@cli :   ...         ...           ...           ...              ...              ...
#@cli :   xn          xn vn         xn yn         xn yn vn         xn yn z3         z3 xn yn vn
output_pinklist :
  skip "${2=\ }"
  itp={'$2'}
  e[^-1] "Write pinklist $1" v -
  ltyp={'ebBN'}
  if {w>4} error "Image wrong colums" fi
  typ={typ=vector4($ltyp);typ[w-1]}
  if {$typ=={'b'}&&$itp=={'s'}} typ=$itp
  elif {$typ=={'B'}&&$itp=={'n'}} typ=$itp fi
  ($typ,32,{'{h}'})
  o.. asc:$1 rm..
  i raw:$1,uchar s +,10 rm[1] a y
  o raw:$1,uchar rm
  u $typ
  v +

#@cli pink_delaunay : _mode
#@cli : Prepare the delaunay triangulation from a list of coordimates (vertices)
#@cli : using the external program pink.delaunay
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
#@cli : $ 2,50,1,1 rand 0,512 pink_delaunay. 0
pink_delaunay : skip ${1=0} v -
  file_rand nn=${}
  output_pinklist. $nn".tmp"
  x 0,"pink.delaunay "$nn".tmp "$nn".del"
  input_pinklist[] $nn".del",$1
  file_rm $nn.tmp
  file_rm $nn.del
  v +

#@cli :: KaRo's Test custom functions

#@cli osteo : [noarg]
#@cli : Load osteoblast cell image (transmitted light)
osteo :
  e[^-1] "Load osteoblast nucleus example image"
  v - l[]
    base642img \
"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"
    nm. osteo
  endl v +
# osteo : v - l[] karo_dtpread ~/Images/Beispiele/tra005.cel,1 rm. nm osteo endl v +
#@cli osteo_ : [noarg]
#@cli : Load osteoblast cell image and cell mask (transmitted light)
osteo_ :
  e[^-1] "Load osteoblast nucleus example image and mask"
  v - l[]
    osteo
    base642img \
"MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTYzIDEgMSAjMjIzCnicVdDLSoJRGIXh5cCxgyYJCgUFlVigRZGZpuXhrrwCRzYp\
qEFQUVFUUqkdsCztbpo0flv+RSibBzZ78H1r7ZpqCvnIel8hQUQNJrVHTAdM6YgZHTOnUzsnqUsWdUVKt6TVZEV3rOqBNbVYV\
4eMHtnQE5t6thfy6lLQq71RDPTY1jsl9SkHBlQCn1T/jN6rY++DMeX/Gb9K+mDHs0cVvXu4t+AcW5Z3ppwN82WdNaO2c7ec/9\
5dmiy7V0o3ds2SuyZ1QUJnLNi8Tpj1f0zrkLj2iWqXCdUJK/v9A/ovmeIxIDExIDEgMSAjMjcKeJxzZ/BliGJgYMhnKGYoYUg\
F0vFAHgApxAN4"
    decompress_rle. nm osteo,osteo_
  endl v +

#@cli follic : [noarg]
#@cli : Load follicle cells sample image from thyroid (transmitted light)
#@cli : For frequent usage do "gmic follic o ${_path_rc}follic.pgm" to store the image locally, \
# follic looks there first!
follic :
	if isfile(['{/${_path_rc}follic.pgm}'])
	  e[^-1] "Load thyroid follicle nuclei example image from local storage"
		i ${_path_rc}follic.pgm
  else e[^-1] "Load thyroid follicle nuclei example image from http://karo03.bplaced.net/gmic/Repo/follic.pgm"
	  i http://karo03.bplaced.net/gmic/Repo/follic.pgm endif nm follic

#@cli follic_ : [noarg]
#@cli : Load follicle cells image and masks from thyroid (transmitted light)
follic_ :
  e[^-1] "Load thyroid follicle nuclei and mask example image"
  v - l[] follic
    base642img \
"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\
hgKGdCDNwAAAZYIFpg=="
    decompress_rle.
    nm follic,follic_
  endl v +

#@cli :: KaRo's Test custom input functions

#@cli karo_read_bd : name,_verbosity(=0),_append_type(=z) {z|c|x|y},_no_delete(=0)
#@cli : Read biodata with external bfconvert from OME
#@cli : bftools directory has to be in the PATH
#@cli : http://www.openmicroscopy.org/site/support/bio-formats5/users/comlinetools/conversion.html
karo_read_bd : skip "${2=0} ${3=z} ${4=0}" ina=$1
 e[^-1] "Read biodata with OME bftool bfconvert (name=\""$ina"\", verbosity=$2, append_type=$3, no_delete=$4)."
  ona=${-path_tmp}${-file_slash}gmic_bd_$_pid.tif
  if {$2<2} postf=" >/dev/null 2>&1" else postf="" endif
  cmd="bfconvert merge overwrite -no-upgrade "${ina}" "${ona}
  if {${is_windows}==0} cmd=${cmd}${postf} else echo_stdout $(cmd) endif
  if isfile(['{/$ina}'])
    if {$2!=0} echo_stdout $cmd v + endif x $cmd if {$2!=0} v - endif
    if isfile(['{/$ona}']) l[]
      i ${ona} if {$!>0} if {'"$3"'=='z'} a z elif {'"$3"'=='c'} a c elif {'"$3"'=='x'} a x elif {'"$3"'=='y'} a y endif endif
      if {$4==0} file_rm $ona else e "File "$ona" not deleted!" endif endl
      else e "File "$ona" not found!" endif
  else e "File "$ina" not found!" endif v +

#@cli gwyddionread : _filename
#@cli : Read gwyddion ASCII file and produce image
#@cli : Data beginning after "Start of Data:" are imported
#@cli : [x-length, y-length, x-offset, y-offset, header lines] are returned in ${}
#@cli : gwyddion Example header
#@cli : |# File Format = ASCII
#@cli : |# Created by Gwyddion 2.48
#@cli : |# Original file: gwyddion_Example.asc
#@cli : |# x-pixels = 640
#@cli : |# y-pixels = 480
#@cli : |# x-length = 313789.96127244376
#@cli : |# y-length = 235219.70492879587
#@cli : |# x-offset = 0
#@cli : |# y-offset = 0
#@cli : |# Bit2nm = 1.0
#@cli : |# Start of Data:
gwyddionread : skip "${1=gwyddion_Example.asc}"
  e[^-1] "Read gwyddion ASCII text data: "$1
  l[]
    i raw:"$1",uchar nm={b}
    # Retrieve header information.
    s +,10
    size_x=-1 size_y=-1
    len_x=-1 len_y=-1
    offs_x=-1 offs_y=-1
    bit2nm=-1
    hend=-1
    repeat $!
      if   {same(['{$>,t}'],'"# x-pixels ="',12)} rows[$>] 12,100% size_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-pixels ="',12)} rows[$>] 12,100% size_y={{$>,t}}
      elif {same(['{$>,t}'],'"# x-length ="',12)} rows[$>] 12,100% len_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-length ="',12)} rows[$>] 12,100% len_y={{$>,t}}
      elif {same(['{$>,t}'],'"# x-offset ="',12)} rows[$>] 12,100% offs_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-offset ="',12)} rows[$>] 12,100% offs_y={{$>,t}}
      elif {same(['{$>,t}'],'"# Bit2nm ="',10)}   rows[$>] 10,100% bit2nm={{$>,t}}
      elif {same(['{$>,t}'],'"# Start of Data:"',16)} hend=$> break
      fi
    done
    if {$hend>0}
      rm[0-{$hend+1}] a y
       #e "Size = ("$size_x,$size_y,$len_x,$len_y,$hend")"
       # Save remaining data as a pure ascii file.
      discard 13
      file_tmp=${-file_rand}
      if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
        o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
      else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm fi
      file_rm $file_tmp
    else rm fi
    u [$len_x,$len_y,$offs_x,$offs_y,$bit2nm]
  endl

#@cli wykoread : _filename
#@cli : Read Wyko/Bruker/Vision ASCII file and produce image(s)
#@cli : Data preceded by "RAW_DATA" and/or "Intensity" are imported
#@cli : Wyko Example header
#@cli : |Wyko ASCII Data File Format 0	1	1
#@cli : |X Size	640
#@cli : |Y Size	480
#@cli : |Block Name	Type	Length	Value
#@cli : |Wavelength	7	4	71.992500
#@cli : |Aspect	7	4	1.000000
#@cli : |Pixel_size	7	4	0.000985
#@cli : |Magnification	8	8	10.050000
#@cli : |ScannerSpeed	7	4	2.315832
#@cli : |RAW_DATA	3	1228800
wykoread : skip "${1=Wyko_Example.ASC}"
  e[^-1] "Read Vision surface profilometry OPD text data: "$1
  l[]
    i raw:"$1",uchar nm={b}
    # Retrieve header information.
    s +,10
    size_x=-1 size_y=-1 hend=-1 rend=-1
    repeat $!
      if   {same(['{$>,t}'],'"X Size"',6)} rows[$>] 6,100% size_x={{$>,t}}
      elif {same(['{$>,t}'],'"Y Size"',6)} rows[$>] 6,100% size_y={{$>,t}}
      elif {same(['{$>,t}'],'"RAW_DATA"',8)} hend=$>
      elif {same(['{$>,t}'],'"Intensity"',9)} rend=$> break
      fi
    done
    if {$hend>0}
      rm[0-{$hend+1}]
      if {$rend>$hend} a[0-{$rend-$hend-3}] y rm[1,2] a[1--1] y else a y fi
      #-e "Size = ("$size_x,$size_y,$hend,$rend")"
      # Save remaining data as a pure ascii file.
      replace_str "Bad","nan"
      discard 13
      file_tmp=${-file_rand}
      if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
        o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
      else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm
      fi
      file_rm $file_tmp
      rotate -90,0
    else rm fi
  endl

#@cli :: KaRo's Test cli custom functions

#@cli cimg2tiff : filenamein, _pathout(=pathin), _type(=integer)
#@cli : File Converter gmic cimg* to tiff e.g. for ImageJ with \
# <_pathout><basename(filenamein)>.tif. \
# Type can be _type='integer'(size dep. uchar(<256)|ushort(<65536)|uint(4294967296)|float) \
# or any other numrical gmic types. \
# Usage is thought for multipage tiff files of 2/3/4d multi-channel data. In case of tiff float files, \
# value ranges other than [0,1] deliver often problems. Best to use (not only in ImageJ) \
# bio-formats package \
# (https://www.openmicroscopy.org/bio-formats/)
#@cli : Ex.: gmic cimg2tiff Step\ 3/_wt_Time_0.cimgz
#@cli : Ex.: gmic cimg2tiff \"Step 3/_wt_Time_0.cimgz\",\"./\"
cimg2tiff :
  i "${1=}"
  skip "${2={f}} ${3=integer}"
  if {['$3']=='integer'}
    if {{iM}<256} ty=uchar
    elif {{iM}<65536} ty=ushort
    elif {{iM}<4294967296} ty=uint
    else ty=float fi
  else ty=$3 fi v +
#  o ${2}${file_slash}{b}.tif,$ty # for problems with Windows
  o ${2}{b}".tif",$ty
  rm

#@cli pseudo_c : Pseudo coloring of greyscale image
pseudo_c : v - if {s!=1} to_gray. fi {iM},1,1,3,u(255) round. map.. . rm.  v +

#@cli sincos : _w(512), _h(512), _new(0)
#@cli : testimage
#@cli : $ sincos , +shift. 50%,0,0,0,2 +shift.. 0,50%,0,0,2 a c
sincos :
  skip "${1=512},${2=$1},${3=0}"
	e[^-1] "Sine/cosine testimage ${1-3}!"
	v - l[]
  if {!(!$3" && "$_version>=216)} $1,$2,1,1,'begin(a=pi*w;b=pi*h);i=sin(a/(x+1))*cos(b/(y+1));if(i<=0,i+=1,i);i*255'
  else
    $1,$2,1,1,'begin(a=pi*w;b=pi*h);sin(a/(x+1))*cos(b/(y+1))'
    +f. 'sign(i)' eq. 1 +neq. 1 *[1] ... *. ... n[-1,-2] 0,255
    f[-1,-2] 'if(i==255,0,i)' +[-1,-2] rm..
  fi
  nm. sincos endl v +

#@cli karo_luminance : _type = [itur1990 | itur1990-2 | gmic | gmic-2]
#@cli : Compute luminance of selected RGB images according
#@cli :   itur1990 | itur1990-2 sqr/sqrt | gmic luminance | sqr/sqrt gmic luminance.
#@cli : sRGB  to RGB and back only with gmic and gmic-2!
#@cli : Default _type=itur1990
#@cli : $ image.jpg +karo_luminance ,
karo_luminance : skip ${1=itur1990}
  e[^-1] "Compute luminance $1 of image$?."
  v -
	remove_opacity
  repeat $! l[$>]
  if {s==3}
   if   {['"$1"']=='gmic'} luminance
   elif {['"$1"']=='gmic-2'} srgb2rgb sh 0 sh[0] 1 sh[0] 2
	   sqr *[1] 0.22248840 *[2] 0.71690369 *[3] 0.06060791 +[1-3] sqrt rm[1] rgb2srgb
   elif {['"$1"']=='itur1990-2'} sh 0 sh[0] 1 sh[0] 2
	   sqr *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] sqrt rm[1]
   else sh 0 sh[0] 1 sh[0] 2 *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] rm[1] fi
  elif {s!=1} norm n 0,255
  fi endl done
  channels 0
  v +

#@cli karo_close : '_size>0','_shape=0|1|2' (square|octagon|circle),'_invert=0|1',
#@cli : '_scale=0|1|2', Value action none | cut | normalize
#@cli : '_channel=>0' see color_channels in apply_channels
#@cli : Morphological closing (dilate and erode) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_close 15 +karo_close[0] 15,1 +karo_close[0] 15,2 rm[0]
karo_close :
  e "Compute closing image"$?", with size "$1" (only 2d)."
  skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
	if $4 negate fi
  ac "-karo_morpho 3,$2,$1",$5,$4
	if $4 negate fi
  v +

#@cli karo_open : '_size>0', '_shape=0|1|2' (square|octagon|circle), '_invert=0|1',
#@cli : '_scale=0|1|2','_channel' see value action, color_channels in 'apply_channels'
#@cli : Morphological opening (erode and dilate) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_open 15 +karo_open[0] 15,1 +karo_open[0] 15,2 rm[0]
karo_open :
  e "Compute opening image"$?", with size "$1" (only 2d)."
  skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
	if $4 negate fi
  ac "-karo_morpho 2,$2,$1",$5,$4
	if $4 negate fi
  v +

#@cli karo_doc : '_size>0','_shape=0|1|2' (square|octagonal|circular),
#@cli : '_channel' see color_channels in 'apply_channels'
#@cli : compute difference of open+close and original (only 2d)
#@cli : $ image.jpg +karo_doc 15,2,5
karo_doc :
  e "Compute difference of open/close and original image"$?", with window size "$1" (only 2d)." v -
  skip ${1=5},${2=1},${3=0}
  repeat $! l[$<]
    +karo_open[0] $1,$2,0,0,$3 +karo_close[0] $1,$2,0,0,$3
    +[-2,-1] /. 2 -
  endl done v +


#@cli karo_doo : _size1>0,_size2>0,_type=0..3 (ero/dil/open/close),_shape=0|1|2 (sqaure|octagon|circle),'_scale=0|1',
#@cli : '_scale','_channel' see value action, color_channels in 'apply_channels'
#@cli : Compute difference of math. morph operation type on selected images (only 2d).
#@cli : $ image.jpg +karo_doo 10,15,2,2,0,3
karo_doo : skip ${1=5},${2=7},${3=2},${4=1},${5=0},${6=0}
  e[^-1] "Compute difference of math. morph. operator \'"${arg\ {$3+1},Erosion,Dilation,Opening,Closing}"\' \
on image"$?", with sizes "$1" and "$2" (only 2d)." v -
  repeat $! l[$<]
    +ac. "-karo_morpho $3,$4,$1",$6,0
#    +fx_morpho. $3,$1,0,$4,$6,0
    ac.. "-karo_morpho $3,$4,$2",$6,0
#     fx_morpho.. $3,$2,0,$4,$6,0
    if {{${3}&1}==0} rv[-2,-1] fi
    -[-2,-1]
    if $5 n. 0,255 fi
  endl done v +

#@cli karo_label_sort :
#@cli : Rearrange a label image (the selected image) according to the region size
#@cli : $ 400,400 rand 0,1 b 3 ge 50% label 0,1 karo_label_sort threshold 50%
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label_sort :
  e[^-1] "Sort labelled image"$?" by region size."
  v - repeat $! l[$>]
   nb={1+iM} mn={im} +histogram. $nb,0,{$nb-1}
   100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
   100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
   map.. . rm.
  endl done v +

#@cli karo_label : tolerance>=0,is_high_connectivity={ 0 | 1 },sort={ 0 | 1} : (+)
#@cli : Label connected components in selected images and possibly sort by region size.
#@cli : Default values: 'tolerance=0', 'is_high_connectivity=0' and 'sort=0'.
#@cli : $ image.jpg luminance threshold 60% label 0 normalize 0,255 map 0
#@cli : $ 400,400 set 1,50%,50% distance 1 mod 16 threshold 8 karo_label 0,,1 mod 255 map 2
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label : check "$1>=0" skip ${2=0} skip ${3=0}
  e[^-1] "Label connected components on image"$?", with tolerance "$1", "${-arg\ 1+!$2,high,low}" \
connectivity and "${-arg\ 1+!$3,sorted,unsorted}" by size"
  v - repeat $! l[$>]
    label. $1,$2
    if {$3}
      nb={1+iM} +histogram. $nb,0,{iM}
      100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
      100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
      map.. . rm.
    fi
  endl done v +

#@cli karo_segmentarea : low
#@cli : Get all 4-connected non-zero regions of area>=low
#@cli : Delete small regions
#@cli : Number of remaining objects in status
karo_segmentarea :
  check "$1>0"
  repeat $! l[$>]
    neq. 0 label_fg. 0,0 +histogram. {iM+1},0,{iM} =. 0,0 ge. $1
    map.. . u {is} rm.
  endl done

#@cli karo_zerleg : Partition of binary image zero areas
#@cli : using pink watershed (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/wshedtopo_8c.html)
#@cli : $ sp 6 to_gray +threshold 140 +karo_zerleg. negate. label_fg. 0
#@cli : Author : <i>KaRo</i>. Latest update : <i>2017/11/30</i>.
karo_zerleg :
  e[^1] "Partition of binary image"$?" with pink watershed" v -
  repeat $! l[$>]
    +distance. 1 pink_wshed. 8,1 f. "j(0,0)!=j(1,1) || j(1,0)!=j(0,1)" skeleton. , or[0,-1]
  endl done v +

#@cli karo_threshold : _method={ triangle | yen | otsu | _otsu | bgt | intermeans | intera | rats | \
# fixnnn | huang | huang2 | li | moments | minerrori | maxentropy | mean | \
# renyientropy | shanbhag | bgt2 },_delclass>0,_smooth>0
#@cli : Calculate threshold (from ImageJ) in range [0,255], evtl. normalization necessary.
#@cli : For each method user function _karo_"_method" is called!
#@cli : If {_delclass > 0} delete cluster {_delclass-1}.
#@cli : If {_smooth > 0} blur_x histogram with amplitude _smooth.
#@cli : No histogram processing for otsu, rats and intera!
#@cli : No test for existence of method!
#@cli : $ image.jpg luminance. karo_threshold. otsu
karo_threshold : skip ${1="triangle"} skip ${2=0} skip ${3=0}
  e[^-1] "Calculate \'"$1"\' thresholded mask from images"$?" with histogram in range [0,255] and binsize 1."
  v -
  if ${-strcontains\ $1,fix} meth=fix
  else meth=$1 fi
  if {['$meth']=='otsu'} otsu 256
  elif {['$meth']=='rats'} karo_rats ,
  elif {['$meth']=='intera'} st={[im,iM]} x_threshold u {st=[$st];round(${}*(st[1]-st[0])+st[0])}
  else repeat $!
    l[$>]
      if {['$meth']=='fix'} _karo_fix ,,$1
      else +histogram. 256,0,255
        if {$2>0} =. 0,{$2-1} fi
        if {$3!=0} tot={is} /. $tot blur_x. $3 /. {is} *. $tot round. fi
        +_karo_$meth. 0,1 rm.
      fi
      th=${}
      threshold[0] $th
# Concatenate results for image list
      if {$>==0} sres=$th else sres=$sres,$th fi
    endl done u $sres fi
  v +

#@cli karo_threshold_demo :
#@cli : Display 4x4 different threshold methods
#@cli : $ osteo karo_threshold_demo , negate.
#@cli : $ sp ? to_gray karo_threshold_demo
karo_threshold_demo : skip ${1=0}
  if !$! error "No image selected!" fi
  e[^1] "Display several threshold methods"
  repeat 16,i
	  arg {$i+1},bgt,huang,huang2,intermeans,li,maxentropy,mean,minerrori,bgt2,moments,otsu,rats,renyientropy,shanbhag,triangle,yen
		meth=${}
		+karo_threshold[0] $meth,,$1 thresh=${}
		text_outline. \ $meth:\ {round($thresh)},0,0,9%,3,1,1,1,1
		e[0] {$i+1},$meth,$thresh
	done append_tiles[1-16] 4

#@cli _karo_fix : 0,1,fixnnn
#@cli : fix threshold nnn returned in status
_karo_fix :
  skip "${1=0} ${2=1} ${3=fix005}"
  u ${-strreplace\ $3,fix,\ }

#@cli _karo_triangle : _minval,_bins
#@cli : Calculate triangle threshold (from ImageJ auto thresholder)
#@cli : tested only with 256 classes from 0 to 255
#@cli : $ image.jpg luminance +histogram 256,0,255 _karo_triangle. , +threshold[0] ${}
_karo_triangle : skip "${1=0} ${2=1}"
  e[^-1] "Calculate triangle threshold from 1d histogram"$?" in range ["$1","{$1+(w-1)*$2}"]."
  v -
  repeat $! l[$>]
    ac=${-autocrop_coords.} wd={w}
    min={${-arg\ 1,$ac}} if {$min==1" && "{@0}!=0} min=0 fi # corr autocrop_coords
    if {$min>0} min={$min-1} fi
    min2={${-arg\ 4,$ac}} if {$min2<{$wd-1}} min2={$min2+1} fi
    dmax={iM} max={xM}
    if {($max-$min)<($min2-$max)}
      inverted=1 mirror[0] x min={$wd-1-$min2} max={$wd-1-$max}
    else inverted=0 fi
    if {$min==$max} split=$min else
      nx={i($max)} ny={$min-$max}
      d={sqrt($nx*$nx+$ny*$ny)}
      nx={$nx/$d} ny={$ny/$d}
      d={$nx*$min+$ny*i($min)}
      +f. x *. $nx *.. $ny +[-1,-2] -. $d
      crop. {$min+1},$max
      if {$inverted} split={$wd-(xM+$min)} else split={xM+$min+1} fi
    fi
    res={$1+$split*$2}
# Concatenate results for image list
    if {$>==0} sres=$res else sres=$sres\,$res fi
    rm[0]
  endl done u $sres v +

#@cli _karo_yen : _minval,_bins
#@cli : Calculate yen threshold (from ImageJ auto thresholder)
_karo_yen :  skip "${1=0} ${2=1}" v -
  repeat $! l[$>]
    if $> r_yen=${} fi
    autocrop_coords. 0 range=${} mn=${-arg\ 1,$range} mx=${-arg\ 4,$range}
    /. {is}
    +cumulate.
    +sqr.. cumulate.
    +mirror... x sqr. cumulate. mirror[-1,-4] x
    *[-1,-2] log. replace_inf. {iM} *. -1
    +*.. -1.0 +. 1.0 *[-1,-3] log.. replace_inf.. {iM} *.. 2.0
    +[-1,-2] k.
    if {$mn>0} repeat $mn =. 0,$> done fi
    if {$mx<(w-1)} repeat {w-$mx} =. 0,{$mx+$>} done fi
    res={xM*$2+$1}
    rm.
    if $> u $r_yen,$res else u $res fi
  endl done v +

#@cli _karo__otsu : _minval(0) _bins(1)
#@cli : Calculate otsu threshold from a histogram
#@cli : with class o = _minval and bin size = _bins
#@cli : Threshold is stored in status
#@cli : $ image.jpg to_gray +histogram 256,0,255 _karo__otsu , threshold ${}
_karo__otsu : skip "${1=0} ${2=1}" v -
  l.
  /. {is}	#p
  +cumulate. x	#q_L
  ++. -1. negate.	#q_h
  +f. "x" +*[0] . rm.. cumulate. x
  ++. {-iM} negate.
  /.. [-4]	#miu_L
  /. ...	#miu_H
  -[-2,-1] sqr.
  *[-1--3] replace_nan. 0.0
  u {xM*$2+$1}
  rm
  endl
  v +

#@cli _karo_bgt : _minval,_bins
#@cli : Autothreshold using SD from whole image starting from the mode of the histogram (image range 0,255)
_karo_bgt: skip "${1=0} ${2=1}" v - fact=1.5
  l.
    hft=${-hist_feature\ -2} mn=${-arg\ 5,$hft} mx=${-arg\ 6,$hft} sd=${-arg\ 4,$hft} md=${-arg\ 1,$hft}
    if {($mx-$md)<=($md-$mn)} res={$md-$fact*$sd}
    else res={$md+$fact*$sd} fi
    u {$res*$2+$1} rm
  endl v +

#@cli _karo_bgt2 : _minval,_bins
#@cli : Threshold using SD from mode left or right distribution mirrored of the histogram (image range 0,255)
#@cli : Estimate from mirrored estimated background peak, derived from mode to left or to right
_karo_bgt2: skip "${1=0} ${2=1} ${3=2.5}" fact=$3
  l.
    hft=${-hist_feature\ -2}
		mn=${-arg\ 5,$hft} mx=${-arg\ 6,$hft} mean=${-arg\ 3,$hft} sd=${-arg\ 4,$hft} md=${-arg\ 1,$hft}
		if {$md>$mean}
		  . eval "md="$md";for(ih=0,ih<md,ih++,i(ih)=0);for(ih=1,ih<w-md,ih++,i(md-ih)=i(md+ih))"
      nsd=${-hist_feature.\ 2} res={$md-$fact*$nsd}
    elif {$md<$mean}
		  . eval "md="$md";for(ih=md+1,ih<w,ih++,i(ih)=0);for(ih=1,ih<md,ih++,i(md+ih)=i(md-ih))"
      nsd=${-hist_feature.\ 2} res={$md+$fact*$nsd}
    else res=$md fi
    u {$res*$2+$1} rm
  endl

#@cli _karo_intermeans : _minval,_bins
#@cli : Calculate intermeans threshold (from ImageJ autothreshold IsoData)
#@cli : from last selected data and store it in status
_karo_intermeans : skip "${1=0} ${2=1}"
  e[^-1] "Calculate intermeans threshold from last selected (1d) histogram$? in range ["$1","{$1+(w-1)*$2}"]." v -
  l. if {h>1" || "d>1" || "s>1} u "?" else
    split={"
      min=0; while(i(min)==0,min++);
      max=w; while(i(max)==0,max--);
      if(min>=max,res=w/2,
        mvI=min;
        do(sum1=sum2=sum3=sum4=0.0;
        for(id=min,id<=mvI,id++,sum1+=id*i(id);sum2+=i(id));
        for(id=mvI+1,id<=max,id++,sum3+=id*i(id);sum4+=i(id));
        res=(sum1/sum2+sum3/sum4)/2.0;mvI++,
        (mvI+1)<=res && mvI<(max-1)));
      round(res)"} rm
    u {$1+$split*$2} fi
  endl v +

#@cli karo_rats : _pow(0.5)
#@cli : Robust automatic threshold selection (Kittler et al. 1985)
#@cli : Input image (not histogram similar otsu!)
karo_rats :
  check ${1=0.5}>0
  e[^-1] "Calculate rats from image$? with power "$1"." v -
  repeat $! l[$>]
    +gradient_norm. pow. $1 gr={is} *. .. gri={is} res={$gri/$gr} rm.
    threshold. $res
# Concatenate results for image list
    if {$>==0} sres=$res else sres=$sres\,$res fi
  endl done
  u $sres v +

_karo_huang : skip "${1=0} ${2=1}"
# public static int Huang(int [] data ) {
# 	// Implements Huang's fuzzy thresholding method
# 	// Uses Shannon's entropy function (one can also use Yager's entropy function)
# 	// Huang L.-K. and Wang M.-J.J. (1995) "Image Thresholding by Minimizing
# 	// the Measures of Fuzziness" Pattern Recognition, 28(1): 41-51
# 	// M. Emre Celebi  06.15.2007
# 	// Ported to ImageJ plugin by G. Landini from E Celebi's fourier_0.8 routines
  huang={"
           threshold=-1;
           first_bin=0;
           for(ih=0,ih<w,if(i(ih)!=0,first_bin=ih;break());ih++);
           last_bin=w-1;
           for(ih=w-1,ih>=first_bin,if(i(ih)!=0,last_bin=ih;break());ih--);
           term = 1.0 / ( last_bin - first_bin );
           mu_0=["{^}"];
           sum_pix = num_pix = 0;
           for ( ih = first_bin, ih < w, sum_pix += ih * i(ih); num_pix += i(ih);
             mu_0[ih] = sum_pix / num_pix; ih++ );
           mu_1 = mu_0;
           sum_pix = num_pix = 0;
           for (ih = last_bin, ih > 0, sum_pix+=ih*i(ih);
             num_pix += i(ih);
             mu_1[ih-1] = sum_pix / num_pix; ih-- );
           min_ent = 1e31;
           for (it = 0, it < w,
             ent = 0.0;
             for (ih = 0,ih<=it,
               mu_x = 1.0 / ( 1.0 + term * abs(ih - mu_0[it]));
               if (!((mu_x  < 1e-06) || (mu_x > 0.999999)),
                 ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
               ih++);
             for (ih = it + 1, ih < w,
               mu_x = 1.0 / ( 1.0 + term * abs (ih - mu_1[it]));
               if (!((mu_x  < 1e-06) || (mu_x > 0.999999)),
                 ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
               ih++);
             if (ent < min_ent, min_ent = ent; threshold = it; _(print(min_ent,threshold)));
             it++ );
           threshold"}
  u {$huang*$2+$1} rm

_karo_huang2 : skip "${1=0} ${2=1}"
  huang2={"
#	// Implements Huang's fuzzy thresholding method
#	// Uses Shannon's entropy function (one can also use Yager's entropy function)
#	// Huang L.-K. and Wang M.-J.J. (1995) "Image Thresholding by Minimizing
#	// the Measures of Fuzziness" Pattern Recognition, 28(1): 41-51
#	// Reimplemented (to handle 16-bit efficiently) by Johannes Schindelin Jan 31, 2011
           for(first=0,first<w && i(first)==0,first++);
           for(last=w-1,last>first && i(last)==0,last--);
           if(first==last,break());
           S=["{^}"]; W=S;
           S[0]=i(0);
           for(ii=max(1,first),ii<=last,S[ii]=S[ii-1]+i(ii);W[ii]=W[ii-1]+ii*i(ii);ii++);
           C=last-first;
           Smu=S;
           for(ii=1,ii<(C+1),mu=1/(1+ii/C);Smu[ii]=-mu*log(mu)-(1-mu)*log(1-mu);ii++);
           bestThreshold = 0;
           bestEntropy = 1e31;
           for(threshold=first,threshold<=last,
             entropy=0; mu=round(W[threshold]/S[threshold]);
             for(ii=first,ii<=threshold,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
             mu=round((W[last] - W[threshold]) / (S[last] - S[threshold]));
             for(ii=threshold+1,ii<=last,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
             if(bestEntropy>entropy,bestEntropy=entropy;bestThreshold=threshold);
             threshold++);
           bestThreshold"}
           u {$huang2*$2+$1} rm

_karo_li : skip "${1=0} ${2=1}"
  li={"
#public static int Li(int [] data ) {
#// Implements Li's Minimum Cross Entropy thresholding method
#// This implementation is based on the iterative version (Ref. 2) of the algorithm.
#// 1) Li C.H. and Lee C.K. (1993) "Minimum Cross Entropy Thresholding"
#//    Pattern Recognition, 26(4): 617-625
#// 2) Li C.H. and Tam P.K.S. (1998) "An Iterative Algorithm for Minimum
#//    Cross Entropy Thresholding"Pattern Recognition Letters, 18(8): 771-776
#// 3) Sezgin M. and Sankur B. (2004) "Survey over Image Thresholding
#//    Techniques and Quantitative Performance Evaluation" Journal of
#//    Electronic Imaging, 13(1): 146-165
#//    http://citeseer.ist.psu.edu/sezgin04survey.html
#// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines
      tolerance=0.5;
      num_pixels=0;
      mean = 0.0;
      for (ih = 0, ih < w, ih++, num_pixels += i(ih);mean += ih * i(ih));
      mean /= num_pixels;
      new_thresh = mean;
      do(
        old_thresh = new_thresh;
        threshold = int(old_thresh+0.5);
        sum_back = 0;
        num_back = 0;
        for ( ih = 0, ih<=threshold, ih++,
          sum_back += ih * i(ih);
          num_back += i(ih));
        if(num_back == 0,mean_back=0.0,mean_back=(sum_back/num_back));
        sum_obj = 0;
        num_obj = 0;
        for ( ih = threshold + 1, ih < w, ih++,
          sum_obj += ih * i(ih);
          num_obj += i(ih));
        if(num_obj == 0,mean_obj=0.0,mean_obj=(sum_obj/num_obj));
        temp = ( mean_back - mean_obj ) / ( log ( mean_back ) - log ( mean_obj ) );
        if (temp < -2.220446049250313e-16, new_thresh=int(temp - 0.5),new_thresh=int(temp + 0.5)),
        abs(new_thresh-old_thresh)>tolerance);
      threshold"}
  u {$li*$2+$1} rm

_karo_moments : skip "${1=0} ${2=1}"
	/ {is} moments={"
# 	public static int Moments(int [] data ) {
# 		//  W. Tsai, "Moment-preserving thresholding: a new approach," Computer Vision,
# 		// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.
# 		// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8
# 		// by  M. Emre Celebi , Department of Computer Science,  Louisiana State University in Shreveport
# 		// Shreveport, LA 71115, USA
# 		//  http://sourceforge.net/projects/fourier-ipal
# 		//  http://www.lsus.edu/faculty/~ecelebi/fourier.htm
#			double total =0;
   m0=1.0; m1=0.0; m2 =0.0; m3 =0.0; sum =0.0; p0=0.0;
# 		double cd, c0, c1, z0, z1;	/* auxiliary variables */
   threshold = -1;
#
# 		double [] histo = new  double [data.length];
#
# 		for (int i=0; i<data.length; i++)
# 			total+=data[i];
#
# 		for (int i=0; i<data.length; i++)
# 			histo[i]=(double)(data[i]/total); //normalised histogram
#
# 		/* Calculate the first, second, and third order moments */
# 		for ( int i = 0; i < data.length; i++ ){
# 			m1 += i * histo[i];
# 			m2 += i * i * histo[i];
# 			m3 += i * i * i * histo[i];
# 		}
   for(ih=0, ih<w, ih++, m1+=ih*i(ih); m2+=ih*ih*i(ih); m3+=ih*ih*ih*i(ih));
# 		/*
# 		First 4 moments of the gray-level image should match the first 4 moments
# 		of the target binary image. This leads to 4 equalities whose solutions
# 		are given in the Appendix of Ref. 1
# 		*/
   cd = m0 * m2 - m1 * m1;
   c0 = ( -m2 * m2 + m1 * m3 ) / cd;
   c1 = ( m0 * -m3 + m2 * m1 ) / cd;
   z0 = 0.5 * ( -c1 - sqrt ( c1 * c1 - 4.0 * c0 ) );
   z1 = 0.5 * ( -c1 + sqrt ( c1 * c1 - 4.0 * c0 ) );
   p0 = ( z1 - m1 ) / ( z1 - z0 );  # /* Fraction of the object pixels in the target binary image */
#
# 		// The threshold is the gray-level closest
# 		// to the p0-tile of the normalized histogram
   sum=0;
   for (ih=0, ih<w, ih++, sum+=i(ih); if (sum>p0, threshold = ih; break()) );
# 			}
# 		}
# 		return threshold;
   threshold"}
  u {$moments*$2+$1} rm

_karo_mean : skip "${1=0} ${2=1}"
	m0={is} +cumulate +f.. "x*i(x)" cumulate. m1={iM}
  u {int($m1/$m0)*$2+$1} rm

_karo_minerrori : skip "${1=0} ${2=1}"
	m0={is} +cumulate +f.. "x*i(x)" cumulate. m1={iM} +f... "x*x*i(x)" cumulate. a y
	minerrori={"
#
# 	public static int Mean(int [] data ) {
# 		// C. A. Glasbey, "An analysis of histogram-based thresholding algorithms,"
# 		// CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.
# 		//
# 		// The threshold is the mean of the greyscale data
# 		int threshold = -1;
# 		double tot=0, sum=0;
# 		for (int i=0; i<data.length; i++){
# 			tot+= data[i];
# 			sum+=(i*data[i]);
# 		}
# 		threshold =(int) Math.floor(sum/tot);
# 		return threshold;
# 	}
# 	public static int MinErrorI(int [] data ) {
# 		  // Kittler and J. Illingworth, "Minimum error thresholding," Pattern Recognition, vol. 19, pp. 41-47, 1986.
# 		 // C. A. Glasbey, "An analysis of histogram-based thresholding algorithms," CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.
# 		// Ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)
# 		// Original Matlab code Copyright (C) 2004 Antti Niemisto
# 		// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation
# 		// and the original Matlab code.
#
# 		int threshold =  Mean(data); //Initial estimate for the threshold is found with the MEAN algorithm.
   threshold=int("$m1"/"$m0");
   Tprev=-2;
	 ll=0;
# 		double mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;
# 		//int counter=1;
# 		while (threshold!=Tprev){
   while(threshold!=Tprev&&ll++<1000,           #echo(ll,' ',threshold,' ',Tprev);
#   while(abs(threshold-Tprev)>1&&ll++<1000,    #echo(ll,' ',threshold,' ',Tprev);
# 			//Calculate some statistics.
# 			mu = B(data, threshold)/A(data, threshold);
    mu=i(threshold,2)/i(threshold,1);
# 			nu = (B(data, data.length - 1)-B(data, threshold))/(A(data, data.length - 1)-A(data, threshold));
    nu=(i(w-1,2)-i(threshold,2))/(i(w-1,1)-i(threshold,1));
# 			p = A(data, threshold)/A(data, data.length - 1);
    p=i(threshold,1)/i(w-1,1);
# 			q = (A(data, data.length - 1)-A(data, threshold)) / A(data, data.length - 1);
    q=(i(w-1,1)-i(threshold,1))/i(w-1,1);
# 			sigma2 = C(data, threshold)/A(data, threshold)-(mu*mu);
    sigma2=i(threshold,3)/i(threshold,1)-(mu*mu);
# 			tau2 = (C(data, data.length - 1)-C(data, threshold)) / (A(data, data.length - 1)-A(data, threshold)) - (nu*nu);
    tau2=(i(w-1,3)-i(threshold,3))/(i(w-1,1)-i(threshold,1))-(nu*nu);
#
# 			//The terms of the quadratic equation to be solved.
    w0 = 1.0/sigma2-1.0/tau2;
    w1 = mu/sigma2-nu/tau2;
    w2 = (mu*mu)/sigma2 - (nu*nu)/tau2 + log10((sigma2*(q*q))/(tau2*(p*p)));
#
# 			//If the next threshold would be imaginary, return with the current one.
    sqterm = (w1*w1)-w0*w2;
# 			if (sqterm < 0) {
# 				IJ.log("MinError(I): not converging. Try \'Ignore black/white\' options");
# 				return threshold;
# 			}
    if(sqterm<0,echo('MinError(I):not converging.');break());
#
# 			//The updated threshold is the integer part of the solution of the quadratic equation.
    Tprev = threshold;
    temp = (w1+sqrt(sqterm))/w0;
#
# 			if ( Double.isNaN(temp)) {
# 				IJ.log ("MinError(I): NaN, not converging.");
# 				threshold = Tprev;
# 			}
# 			else
# 				threshold =(int) Math.floor(temp);
# 			//IJ.log("Iter: "+ counter+++"  t:"+threshold);
# 		}
    if(isnan(temp),echo('MinError(I):NaN,not converging.');threshold=Tprev,threshold=floor(temp));
	 );
# 		return threshold;
# 	}
#
# 	protected static double A(int [] y, int j) {
# 		double x = 0;
# 		for (int i=0;i<=j;i++)
# 			x+=y[i];
# 		return x;
# 	}
#
# 	protected static double B(int [] y, int j) {
# 		double x = 0;
# 		for (int i=0;i<=j;i++)
# 			x+=i*y[i];
# 		return x;
# 	}
#
# 	protected static double C(int [] y, int j) {
# 		double x = 0;
# 		for (int i=0;i<=j;i++)
# 			x+=i*i*y[i];
# 		return x;
# 	}
   threshold"}
  u {$minerrori*$2+$1} rm

_karo_maxentropy : skip "${1=0} ${2=1}"
	+/. {is} +cumulate. +*. -1 +. 1.0 a y
	maxentropy={"
# 	public static int MaxEntropy(int [] data ) {
# 		// Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method
# 		// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) "A New Method for
# 		// Gray-Level Picture Thresholding Using the Entropy of the Histogram"
# 		// Graphical Models and Image Processing, 29(3): 273-285
# 		// M. Emre Celebi
# 		// 06.15.2007
# 		// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines
# 		int threshold=-1;
# 		int ih, it;
# 		int first_bin;
# 		int last_bin;
# 		double tot_ent;  /* total entropy */
# 		double max_ent;  /* max entropy */
# 		double ent_back; /* entropy of the background pixels at a given threshold */
# 		double ent_obj;  /* entropy of the object pixels at a given threshold */
# 		double [] norm_histo = new double[data.length]; /* normalized histogram */
# 		double [] P1 = new double[data.length]; /* cumulative normalized histogram */
# 		double [] P2 = new double[data.length];
#
# 		int total =0;
# 		for (ih = 0; ih < data.length; ih++ )
# 			total+=data[ih];
#
# 		for (ih = 0; ih < data.length; ih++ )
# 			norm_histo[ih] = (double)data[ih]/total;
#
# 		P1[0]=norm_histo[0];
# 		P2[0]=1.0-P1[0];
# 		for (ih = 1; ih < data.length; ih++ ){
# 			P1[ih]= P1[ih-1] + norm_histo[ih];
# 			P2[ih]= 1.0 - P1[ih];
# 		}
#
# 		/* Determine the first non-zero bin */
# 		first_bin=0;
# 		for (ih = 0; ih < data.length; ih++ ) {
# 			if ( !(Math.abs(P1[ih])<2.220446049250313-16)) {
# 				first_bin = ih;
# 				break;
# 			}
# 		}
   first_bin=0; for(ih=0,ih<w,ih++,if(!(abs(i(ih,2))<2.220446049250313e-16),first_bin=ih;break()));
#
# 		/* Determine the last non-zero bin */
# 		last_bin=data.length - 1;
# 		for (ih = data.length - 1; ih >= first_bin; ih-- ) {
# 			if ( !(Math.abs(P2[ih])<2.220446049250313E-16)) {
# 				last_bin = ih;
# 				break;
# 			}
# 		}
   last_bin=w-1; for(ih=w-1,ih>=first_bin,ih--,if(!(abs(i(ih,3))<2.220446049250313e-16),last_bin=ih;break()));
#
# 		// Calculate the total entropy each gray-level
# 		// and find the threshold that maximizes it
# 		max_ent = Double.MIN_VALUE;
   max_ent=-1.E16;
#
# 		for ( it = first_bin; it <= last_bin; it++ ) {
   for(it=first_bin,it<=last_bin,it++,
# 			/* Entropy of the background pixels */
# 			ent_back = 0.0;
# 			for ( ih = 0; ih <= it; ih++ )  {
# 				if ( data[ih] !=0 ) {
# 					ent_back -= ( norm_histo[ih] / P1[it] ) * Math.log ( norm_histo[ih] / P1[it] );
# 				}
# 			}
    ent_back=0.0; for(ih=0,ih<=it,ih++,if(i(ih,0)!=0,ent_back-=(i(ih,1)/i(it,2)) * log(i(ih,1)/i(it,2))));
#
# 			/* Entropy of the object pixels */
# 			ent_obj = 0.0;
# 			for ( ih = it + 1; ih < data.length; ih++ ){
# 				if (data[ih]!=0){
# 				ent_obj -= ( norm_histo[ih] / P2[it] ) * Math.log ( norm_histo[ih] / P2[it] );
# 				}
# 			}
    ent_obj=0.0; for(ih=it+1,ih<w,ih++,if(i(ih,0)!=0,ent_obj-=(i(ih,1)/i(it,3)) * log(i(ih,1)/i(it,3))));
#
# 			/* Total entropy */
    tot_ent = ent_back + ent_obj;
#
# 			// IJ.log(""+max_ent+"  "+tot_ent);
# 			if ( max_ent < tot_ent ) {
# 				max_ent = tot_ent;
# 				threshold = it;
# 			}
    if(max_ent<tot_ent,max_ent=tot_ent;threshold=it);
# 		}
# 		return threshold;
# 	}
	 );
   threshold"}
  u {$maxentropy*$2+$1} rm

_karo_renyientropy : skip "${1=0} ${2=1}"
	+/. {is} +cumulate. +*. -1 +. 1.0 a y
	renyientropy={"
# 	public static int RenyiEntropy(int [] data ) {
# 		// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) "A New Method for
# 		// Gray-Level Picture Thresholding Using the Entropy of the Histogram"
# 		// Graphical Models and Image Processing, 29(3): 273-285
# 		// M. Emre Celebi
# 		// 06.15.2007
# 		// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines
#
# 		int threshold;
# 		int opt_threshold;
#
# 		int ih, it;
# 		int first_bin;
# 		int last_bin;
# 		int tmp_var;
# 		int t_star1, t_star2, t_star3;
# 		int beta1, beta2, beta3;
# 		double alpha;/* alpha parameter of the method */
# 		double term;
# 		double tot_ent;  /* total entropy */
# 		double max_ent;  /* max entropy */
# 		double ent_back; /* entropy of the background pixels at a given threshold */
# 		double ent_obj;  /* entropy of the object pixels at a given threshold */
# 		double omega;
# 		double [] norm_histo = new double[data.length]; /* normalized histogram */
# 		double [] P1 = new double[data.length]; /* cumulative normalized histogram */
# 		double [] P2 = new double[data.length];
#
# 		int total =0;
# 		for (ih = 0; ih < data.length; ih++ )
# 			total+=data[ih];
#
# 		for (ih = 0; ih < data.length; ih++ )
# 			norm_histo[ih] = (double)data[ih]/total;
#
# 		P1[0]=norm_histo[0];
# 		P2[0]=1.0-P1[0];
# 		for (ih = 1; ih < data.length; ih++ ){
# 			P1[ih]= P1[ih-1] + norm_histo[ih];
# 			P2[ih]= 1.0 - P1[ih];
# 		}
#
# 		/* Determine the first non-zero bin */
# 		first_bin=0;
# 		for (ih = 0; ih < data.length; ih++ ) {
# 			if ( !(Math.abs(P1[ih])<2.220446049250313E-16)) {
# 				first_bin = ih;
# 				break;
# 			}
# 		}
   first_bin=0; for(ih=0,ih<w,ih++,if(!(abs(i(ih,2))<2.220446049250313e-16),first_bin=ih;break()));
#
# 		/* Determine the last non-zero bin */
# 		last_bin=data.length - 1;
# 		for (ih = data.length - 1; ih >= first_bin; ih-- ) {
# 			if ( !(Math.abs(P2[ih])<2.220446049250313E-16)) {
# 				last_bin = ih;
# 				break;
# 			}
# 		}
   last_bin=(w-1); for(ih=w-1,ih>=first_bin,ih--,if(!(abs(i(ih,3))<2.220446049250313e-16),last_bin=ih;break()));
#
# 		/* Maximum Entropy Thresholding - BEGIN */
# 		/* ALPHA = 1.0 */
# 		/* Calculate the total entropy each gray-level
# 		and find the threshold that maximizes it
# 		*/
   threshold=0; #// was MIN_INT in original code, but if an empty image is processed it gives an error later on.
   max_ent = 0.0;
#
# 		for ( it = first_bin; it <= last_bin; it++ ) {
   for(it=first_bin,it<=last_bin,it++,
# 			/* Entropy of the background pixels */
    ent_back = 0.0;
# 			for ( ih = 0; ih <= it; ih++ )  {
# 				if ( data[ih] !=0 ) {
# 					ent_back -= ( norm_histo[ih] / P1[it] ) * Math.log ( norm_histo[ih] / P1[it] );
# 				}
# 			}
    for(ih=0,ih<=it,ih++,if(i(ih,0)!=0,ent_back-=(i(ih,1)/i(it,2)) * log(i(ih,1)/i(it,2))));
#
# 			/* Entropy of the object pixels */
    ent_obj = 0.0;
# 			for ( ih = it + 1; ih < data.length; ih++ ){
# 				if (data[ih]!=0){
# 				ent_obj -= ( norm_histo[ih] / P2[it] ) * Math.log ( norm_histo[ih] / P2[it] );
# 				}
# 			}
    for(ih=it+1,ih<w,ih++,if(i(ih,0)!=0,ent_obj-=(i(ih,1)/i(it,3)) * log(i(ih,1)/i(it,3))));
#
# 			/* Total entropy */
    tot_ent = ent_back + ent_obj;
#
# 			// IJ.log(""+max_ent+"  "+tot_ent);
#
# 			if ( max_ent < tot_ent ) {
# 				max_ent = tot_ent;
# 				threshold = it;
# 			}
    if(max_ent<tot_ent,max_ent=tot_ent;threshold=it);
# 		}
	 );
   t_star2 = threshold;
#
# 		/* Maximum Entropy Thresholding - END */
   threshold=0; #//was MIN_INT in original code, but if an empty image is processed it gives an error later on.
   max_ent = 0.0;
   alpha = 0.5;
   term = 1.0 / ( 1.0 - alpha );
# 		for ( it = first_bin; it <= last_bin; it++ ) {
   for(it=first_bin,it<=last_bin,it++,
# 			/* Entropy of the background pixels */
    ent_back = 0.0;
# 			for ( ih = 0; ih <= it; ih++ )
# 				ent_back += Math.sqrt ( norm_histo[ih] / P1[it] );
    for(ih=0,ih<=it,ih++,ent_back+=sqrt(i(ih,1)/i(it,2)));
#
# 			/* Entropy of the object pixels */
    ent_obj = 0.0;
# 			for ( ih = it + 1; ih < data.length; ih++ )
# 				ent_obj += Math.sqrt ( norm_histo[ih] / P2[it] );
    for(ih=it+1,ih<w,ih++,ent_obj+=sqrt(i(ih,1)/i(it,3)));
#
# 			/* Total entropy */
    tot_ent = term * ( ( ent_back * ent_obj ) > 0.0 ? log ( ent_back * ent_obj ) : 0.0);
#
# 			if ( tot_ent > max_ent ){
# 				max_ent = tot_ent;
# 				threshold = it;
# 			}
# 		}
    if(tot_ent>max_ent,max_ent=tot_ent;threshold=it);
	 );
#
   t_star1 = threshold;
#
   threshold = 0; #//was MIN_INT in original code, but if an empty image is processed it gives an error later on.
   max_ent = 0.0;
   alpha = 2.0;
   term = 1.0 / ( 1.0 - alpha );
# 		for ( it = first_bin; it <= last_bin; it++ ) {
   for(it=first_bin,it<=last_bin,it++,
# 			/* Entropy of the background pixels */
    ent_back = 0.0;
# 			for ( ih = 0; ih <= it; ih++ )
# 				ent_back += ( norm_histo[ih] * norm_histo[ih] ) / ( P1[it] * P1[it] );
    for(ih=0,ih<=it,ih++,ent_back+=(i(ih,1)*i(ih,1))/(i(it,2)*i(it,2)));
#
# 			/* Entropy of the object pixels */
    ent_obj = 0.0;
# 			for ( ih = it + 1; ih < data.length; ih++ )
# 				ent_obj += ( norm_histo[ih] * norm_histo[ih] ) / ( P2[it] * P2[it] );
    for(ih=it+1,ih<w,ih++,ent_obj+=(i(ih,1)*i(ih,1))/(i(it,3)*i(it,3)));
#
# 			/* Total entropy */
    tot_ent = term *( ( ent_back * ent_obj ) > 0.0 ? log(ent_back * ent_obj ): 0.0 );
#
# 			if ( tot_ent > max_ent ){
# 				max_ent = tot_ent;
# 				threshold = it;
# 			}
    if(tot_ent>max_ent,max_ent=tot_ent;threshold=it);
# 		}
	 );
#
   t_star3 = threshold;
#
# 		/* Sort t_star values */
# 		if ( t_star2 < t_star1 ){
# 			tmp_var = t_star1;
# 			t_star1 = t_star2;
# 			t_star2 = tmp_var;
# 		}
   if(t_star2<t_star1,tmp_var=t_star1;t_star1=t_star2;t_star2=tmp_var);
# 		if ( t_star3 < t_star2 ){
# 			tmp_var = t_star2;
# 			t_star2 = t_star3;
# 			t_star3 = tmp_var;
# 		}
   if(t_star3<t_star2,tmp_var=t_star2;t_star2=t_star3;t_star3=tmp_var);
# 		if ( t_star2 < t_star1 ) {
# 			tmp_var = t_star1;
# 			t_star1 = t_star2;
# 			t_star2 = tmp_var;
# 		}
   if(t_star2<t_star1,tmp_var=t_star1;t_star1=t_star2;t_star2=tmp_var);
#
# 		/* Adjust beta values */
# 		if ( Math.abs ( t_star1 - t_star2 ) <= 5 )  {
   if(abs(t_star1-t_star2)<=5,
	  if(abs(t_star2-t_star3)<=5,beta1=1;beta2=2;beta3=1,beta1=0;beta2=1;beta3=3),
	  if(abs(t_star2-t_star3)<=5,beta1=3;beta2=1;beta3=0,beta1=1;beta2=2;beta3=1));
# 			if ( Math.abs ( t_star2 - t_star3 ) <= 5 ) {
# 				beta1 = 1;
# 				beta2 = 2;
# 				beta3 = 1;
# 			}
# 			else {
# 				beta1 = 0;
# 				beta2 = 1;
# 				beta3 = 3;
# 			}
# 		}
# 		else {
# 			if ( Math.abs ( t_star2 - t_star3 ) <= 5 ) {
# 				beta1 = 3;
# 				beta2 = 1;
# 				beta3 = 0;
# 			}
# 			else {
# 				beta1 = 1;
# 				beta2 = 2;
# 				beta3 = 1;
# 			}
# 		}
# 		//IJ.log(""+t_star1+" "+t_star2+" "+t_star3);
# 		/* Determine the optimal threshold value */
# 		omega = P1[t_star3] - P1[t_star1];
   omega=i(t_star3,2)-i(t_star1,2);
# 		opt_threshold = (int) (t_star1 * ( P1[t_star1] + 0.25 * omega * beta1 ) + 0.25 * t_star2 * omega * beta2  + t_star3 * ( P2[t_star3] + 0.25 * omega * beta3 ));
   opt_threshold=int((t_star1*(i(t_star1,2)+0.25*omega*beta1)+0.25*t_star2*omega*beta2+t_star3*(i(t_star3,3)+0.25*omega*beta3)));
#
# 		return opt_threshold;
# 	}
   opt_threshold"}
  u {$renyientropy*$2+$1} rm
#
#
_karo_shanbhag : skip "${1=0} ${2=1}"
	+/. {is} +cumulate. +*. -1 +. 1.0 a y
	shanbhag={"
# 	public static int Shanbhag(int [] data ) {
# 		// Shanhbag A.G. (1994) "Utilization of Information Measure as a Means of
# 		//  Image Thresholding" Graphical Models and Image Processing, 56(5): 414-419
# 		// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines
# 		int threshold;
# 		int ih, it;
# 		int first_bin;
# 		int last_bin;
# 		double term;
# 		double tot_ent;  /* total entropy */
# 		double min_ent;  /* max entropy */
# 		double ent_back; /* entropy of the background pixels at a given threshold */
# 		double ent_obj;  /* entropy of the object pixels at a given threshold */
# 		double [] norm_histo = new double[data.length]; /* normalized histogram */
# 		double [] P1 = new double[data.length]; /* cumulative normalized histogram */
# 		double [] P2 = new double[data.length];
#
# 		int total =0;
# 		for (ih = 0; ih < data.length; ih++ )
# 			total+=data[ih];
#
# 		for (ih = 0; ih < data.length; ih++ )
# 			norm_histo[ih] = (double)data[ih]/total;
#
# 		P1[0]=norm_histo[0];
# 		P2[0]=1.0-P1[0];
# 		for (ih = 1; ih < data.length; ih++ ){
# 			P1[ih]= P1[ih-1] + norm_histo[ih];
# 			P2[ih]= 1.0 - P1[ih];
# 		}
#
# 		/* Determine the first non-zero bin */
# 		first_bin=0;
# 		for (ih = 0; ih < data.length; ih++ ) {
# 			if ( !(Math.abs(P1[ih])<2.220446049250313E-16)) {
# 				first_bin = ih;
# 				break;
# 			}
# 		}
   first_bin=0; for(ih=0,ih<w,ih++,if(!(abs(i(ih,2))<2.220446049250313e-16),first_bin=ih;break()));
#
# 		/* Determine the last non-zero bin */
# 		last_bin=data.length - 1;
# 		for (ih = data.length - 1; ih >= first_bin; ih-- ) {
# 			if ( !(Math.abs(P2[ih])<2.220446049250313E-16)) {
# 				last_bin = ih;
# 				break;
# 			}
# 		}
   last_bin=(w-1); for(ih=w-1,ih>=first_bin,ih--,if(!(abs(i(ih,3))<2.220446049250313e-16),last_bin=ih;break()));
#
# 		// Calculate the total entropy each gray-level
# 		// and find the threshold that maximizes it
   threshold =-1;
   min_ent = 4503599627370496.0;
#
# 		for ( it = first_bin; it <= last_bin; it++ ) {
   for(it=first_bin,it<=last_bin,it++,
# 			/* Entropy of the background pixels */
    ent_back = 0.0;
    term = 0.5 / i(it,2);  #P1[it];
# 			for ( ih = 1; ih <= it; ih++ )  { //0+1?
# 				ent_back -= norm_histo[ih] * Math.log ( 1.0 - term * P1[ih - 1] );
# 			}
    for(ih=1,ih<=it,ih++,ent_back-=i(ih,1)*log(1.0-term*i(ih-1,2)));
    ent_back *= term;
#
# 			/* Entropy of the object pixels */
    ent_obj = 0.0;
    term = 0.5 / i(it,3);  #P2[it];
# 			for ( ih = it + 1; ih < data.length; ih++ ){
# 				ent_obj -= norm_histo[ih] * Math.log ( 1.0 - term * P2[ih] );
# 			}
    for(ih=it+1,ih<w,ih++,ent_obj-=i(ih,1)*log(1.0-term*i(ih,3)));
    ent_obj *= term;
#
# 			/* Total entropy */
    tot_ent = abs ( ent_back - ent_obj );
#
# 			if ( tot_ent < min_ent ) {
# 				min_ent = tot_ent;
# 				threshold = it;
# 			}
    if(tot_ent<min_ent,min_ent=tot_ent;threshold=it);
# 		}
	 );
# 		return threshold;
# 	}
   threshold"}
  u {$shanbhag*$2+$1} rm

#@cli _kr_histogram : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : Computes the histogram and returns in status the value of first class
#@cli : and the bin size per image.
#@cli : Default values: 'nb_levels=256', '_value0=0%', '_value1=100%'
#@cli : $ sp barbara /. 2 +. 32 _kr_histogram , e ${} dg 600,300,3
_kr_histogram : skip "${1=256} ${2=0%} ${3=100%}" v -
	v + e[^-1] "Calculate histgram with $1 classes in range [${2-3}] from image$?." v -
	repeat $! l[$>]
    if ${-is_percent\ $2} mn={im+(iM-im)*$2} else mn=$2 fi
    if ${-is_percent\ $3} mx={im+(iM-im)*$3} else mx=$3 fi
	  if {$>==0} st=$mn,{($mx-$mn)/($1-1)} else  st=$st,$mn,{($mx-$mn)/($1-1)} fi
		histogram. $1,$mn,$mx
	endl done u $st v +

#@cli _kr_histogram8 : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : same as _kr_histogram, still defaults to byte data (256,0,255) instead of (256,0%,100%)
#@cli : $ sp dog _kr_histogram8 {iM-im+1},{im},{iM} e ${} dg 600,300,3
_kr_histogram8 : skip "${1=256} ${2=0} ${3=255}"
	e[^-1] "Calculate histgram with $1 classes in range [${2-3}] from image$?."
  v - repeat $! l[$>] _kr_histogram. ${1-3} endl done v +

#@cli hist_percentile : _nth[%],_zero={0|1},_min0,_stepw
#@cli : Estimation of _nth percentiles (lower & upper) from histogram and returning value(s) in status (${})
#@cli : _zero Class 0 is zeroed if !=0
#@cli : _min0 value of class 0
#@cli : _stepw value of class width (bin size)
#@cli : Default values: 'nth=25%', '_zero=0', '_min0=0', '_stepw=1'
#@cli : $ image.jpg luminance +dh ,,256,0,255 histogram.. 256,0,255 hist_percentile.. , rm.. t=${} text $t,40,5,23,1,128
hist_percentile :
  check "${1=25%}>=0"
  skip ${2=0},${3=0},${4=1}
  e[^-1] "Calculate $1 percentile from 1d histogram$?."
  v - repeat $!
    l[$>]
      if {h>1" || "d>1" || "s>1} v + e[^-1] "Image "$>" seemingly not 1d!" v - continue fi
  # Delete class zero
      if {$2!=0} set. 0,0 fi
  # Calculate features
      m0={is}
      N={if(${"-is_percent $1"},$m0*$1,$1)}
      if {{$m0*$1}==0} N=1 O=$m0 else O={$m0-$N} fi
  #-echo_stdout $m0,$N
  # Percentile
      +cumulate.
      +ge. $N mn={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm.
      +ge. $O mx={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm[-1,-2]
  # Prepare result for one image
      res=$mn\,$mx
  # Concatenate results for image list
      if {$>==0} sres=$res else sres=$sres\,$res fi
    endl
  done u $sres v +

#@cli hist_feature : _nofeature>=-2,_nth>0,_zero={0|1},_min0,_stepw,_percent[%]>0
#@cli : Estimation from histogram (frequency dist, 1d image) the features
#@cli :  'mode','sum' (m0),'mean' (m1),'SD' (m2),'min','max','median','iqr' (hiq-loq+1),\
# 'loq','hiq' returned in status (${}).
#@cli : nofeature=-2 mode,m0,m1,m2,min,max,med,iqr,loq,hiq,
#@cli :   -1 mode,0 sum,1 mean,2 SD,3 min,4 max,5 median,
#@cli :    6 iqr (interquantile range),7 loq (lower quantile),8 hiq (higer qunatile)
#@cli : nth extreme value (nth+1 occurence!)
#@cli : zero Class 0 is zeroed if !=0
#@cli : min0 value of class 0
#@cli : stepw value of class width (bin size)
#@cli : percent quantile
#@cli : Default valalues: '_nofeature=-2', '_nth=1', '_zero=0', '_min0=0', '_stepw=1', '_percent=25%'
#@cli : Updated 140314 (smoothing replaced by nth selection)
#@cli : Updated 100817 (percent parameter and iqr,loq,hiq feature added)
#@cli : $ image.jpg luminance +histogram 256,0,255 dh.. ,,256,0,255 hist_feature , \
# repeat 8 t={_arg($>+1${})} text $t,40,{$>*25+5},23,1,128 done rm.
hist_feature :
  check ${1=-2}>=-2" && "$1<=8" && "isint($1)" && "isint(${2=1})" && "$2>0
  skip ${3=0},${4=0},${5=1},${6=25%}
  e[^-1] "Calculate md,m0,m1,m2,$2.min,$2.max,med,iqr,loq,hiq from 1d histogram$?."
  v -
  repeat $!
    l[$>]
      if {h>1" || "d>1" || "s>1} v + e[^-1] "Data["$>"] seemingly not 1d!" v - continue fi
  # Delete class zero
      if {$3!=0} =. 0,0 fi
  # Calculate features
      md={xM*$5+$4}
      m0={is}
      +*. 'x*$5+$4' m1={is/$m0} rm.
      +*. '(x*$5+$4)^2' m2={sqrt(is/$m0-$m1^2)} rm.
  # nth-min, nth-max, Median
      mn={"l=0; su=i(0); while(su<"$2" && l<w, l++; su+=i(l)); l*"$5"+"$4}
      mx={"l=w; su=0; while(su<"$2" && l>=0,l--; su+=i(l)); l*"$5"+"$4}
      med1={"l=0; su=0; while(su<=(is/2) && l<w, su+=i(l); l++); l"}
      med2={"l=w; su=0; while(su<=(is/2) && l>=0, l--; su+=i(l)); l"}
      med={($med1+$med2)/2*$5+$4}
  # iqr
      hist_percentile. $6,$3,$4,$5 qu=${}
      hiq=${-arg\ 2,$qu}
      loq=${-arg\ 1,$qu}
      iqr={${-arg\ 2,$qu}-${-arg\ 1,$qu}+1}
      if {$iqr<-1} iqr-=2 fi
  # Prepare result for one image
      res=$md\,$m0\,$m1\,$m2\,$mn\,$mx\,$med\,$iqr\,$loq\,$hiq
      if {$1>-2} res=${-arg\ {$1+2},$res} fi
  # Concatenate results for image list
     if {$>==0} sres=$res else sres=$sres\,$res fi
    endl
  done u $sres v +

#@cli hist_feature_demo : Parameters like in hist_feature
#@cli : (Plot) of features in blue into the histogram with Gaussian in green
#@cli : $ sp 0 luminance +threshold 40 * histogram 256,0,255 = 0,0 hist_feature_demo , dg 600,300,3
hist_feature_demo :
  check ${1=-2}>=-2" && "$1<=8" && "isint($1)" && "isint(${2=1})" && "$2>0
  skip ${3=0},${4=0},${5=1},${6=25%}
  e[^-1] "Plot features from hist_feature into 1d histogram$?." v -
  l.
  hist_feature. -2,${2-6} vv=${}
  md=${-arg\ 1,$vv} m0=${-arg\ 2,$vv} m1=${-arg\ 3,$vv} m2=${-arg\ 4,$vv}
  mn=${-arg\ 5,$vv} mx=${-arg\ 6,$vv} med=${-arg\ 7,$vv}
  lo=${-arg\ 9,$vv} hi=${-arg\ 10,$vv}
  +gaussian. $m2,0,0 shift. {-w/2+$m1} *. {$m0/is} round. 1
  v={iM#-2}
  +*. 0
  =. $v,$md =. $v,$m1 =. {$v*0.25},$mn =. {$v*0.25},$mx =. $v,$med
  =. {$v*(1-$6)},$lo =. {$v*(1-$6)},$hi
  a c
  u $vv
  endl v +

#@cli karo_nth_max : _n(1),_ind(=0)
#@cli : Return in the status the _n-th max or the index of the n-th max of an image
#@cli : Possibility to fetch the index instead of the value (_ind=1)
karo_nth_max : check isint(${1=1})" && "$1>0 skip ${2=0}
  e[^-1] "Return in the status the $1-th max of image$?."
  v - repeat $! l[$>]
#     [0] repeat {$1-1} set. {im},{[xM,yM,zM,cM]} done
#     if $2 mx={xM} else mx={iM} fi rm.
     if {$2} eval argkth(-$1,{^}) u {${}-1} else eval kth(-$1,{^}) fi mx=${}
     if {$>==0} mx1=$mx else mx1=$mx1,$mx fi
  endl done u $mx1 v +

#@cli karo_nth_min : _n(1),_ind(=0)
#@cli : Return in the status the _n-th min of an image or the index of the _n-th min of an image
#@cli : Possibility to fetch the index instead of the value (_ind!=1)
karo_nth_min : check isint(${1=1})" && "$1>0 skip ${2=0}
  e[^-1] "Return in the status the $1-th min of image$?."
  v - repeat $! l[$>]
#     [0] repeat {$1-1} set. {iM},{[xm,ym,zm,cm]} done
#     if $2 mn={xm} else mn={-im} fi rm.
     if {$2} eval argkth($1,{^}) u {${}-1} else eval kth($1,{^}) fi mn=${}
     if {$>==0} mn1=$mn else mn1=$mn1,$mn fi
  endl done u $mn1 v +

#@cli karo_xcimg : programname ,parameterlist :
#@cli : Call external CImg Example 'programname'
#@cli : which has to be found in PATH by external call by
#@cli : 'programname' image_in 'parameterlist' image_out
#@cli : with writing image_in and reading after execution image_out
karo_xcimg :
  filename=${-file_rand}
  if {!${-is_windows}}
    x "which "$1" >/dev/null 2>&1"
    if ${} v + e "executable $1 not found in PATH, status = "${}"!! Returning!!\n" v -
    {w},{h} karos_error "exec Error !!" return fi
  fi
  o ${filename}.cimg
  x "$1 -i "${filename}".cimg $2 -o "${filename}".cimg"
  if ${} v + e "Status is "${}"." v - {w},{h} karos_error "exec Error !!"
  else i ${filename}.cimg fi
  file_rm ${filename}.cimg

#@cli karo_li2st : p1,p2,...,pn
#@cli : Convert comma separated list to space separated string.
karo_li2st :
  v - u "" if {$#>=1} ({"'${1--1}'"}) replace. {','},{"' '"} u {t} rm. fi v +

#@cli karo_skeleton : _p1,..,p2n : (-median,0,-inv,0|1,-t,-0.3,-curve,0|1,-corr,0|1,-dlt,1)
#@cli : Execute use_skeleton (CImg demo) external.
#@cli : E.G. ... karo_skeleton "-median,5,-inv,1"
#@cli : For help execute $ use_skeleton -help in shell
karo_skeleton : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
  e "Compute use_skeleton exec with options \'"$p"\' on"$? v -
  repeat $! l[$>]
   s={s} if {$s>1} s. c fi
   repeat $! l[$>] karo_xcimg use_skeleton,${p}" -visu 0" mv. 0 k[0] endl done
   if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli karo_nlmeans : _p1,..,pn=-zoom,1,-ng,0|1,-nu,0|1,-ns,0|1,-p,1,-lambda,-1,-sigma,-1,-alpha,3,-sampling,1
#@cli : Execute use_nlmeans  (CImg demo) external. (see also q-nlmeans p=4,lambda=4,sigma=10)
#@cli : For help execute $ use_nlmeans -help in shell
karo_nlmeans : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
  e "Compute use_nlmeans exec with options "${p}" on"$? v -
  repeat $! l[$>]
   s={s} if {$s>1} s. c fi
   repeat $! l[$>] karo_xcimg use_nlmeans,${p}" -visu 0" mv. 0 k[0] endl done
   if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli karo_VST : _inverse(=0)
#@cli : Variance Stabilizing Transformation
#@cli : following http://hal.archives-ouvertes.fr/docs/00/51/08/66/PDF/Burst_Hal.pdf
#@cli : $ image.jpg e ${-std_noise} karo_VST 0 e ${-std_noise} +karo_VST 1
karo_VST :
  v - skip ${1=0} if $1 inv=" (inverse)." else inv="." fi v +
  e[^-1] "Variance Stabilizing Transformation"$inv v -
  repeat $! l[$>]
    if $1 /[0] 2 sqr[0] -[0] {3/8} else +[0] {3/8} sqrt[0] *[0] 2 fi
  endl done v +

#@cli pearson_correlation
#@cli : Compute pearson-correlation using two-by-two selected images.
#@cli : $ image.jpg +shift -30,-20 pearson_correlation e ${}
pearson_correlation :
  e[^-1] "Compute pearson-correlation using two-by-two image"$?"."
  v - repeat {int($!/2)} l[{$>*2},{$>*2+1}]
    +-[0] {0,ia} +-[1] {1,ia} +*[2,3]
    sqr[2,3] #-*[2,3]
    r={ia/sqrt({2,ia}*{3,ia})}
    if {$>==0} u $r else u ${},$r fi
    rm[2-4]
  endl done v +

#@cli karo_extinction : _whitevalue[%]
#@cli : Convert (integer) transmission image into extinction with _whitevalue.
#@cli : Def. val.: '_whitevalue=100%'
karo_extinction : check "${1=100%}>0"
  e[^-1] "Convert transmission image"$?" into extinction with white value "$1"." v -
  repeat $! l[$>]
    if ${-is_percent\ $1} WW={iM*$1} else WW=$1 fi
    c. 1,{iM} /. $WW log10. *. -1
  endl done v +

#@cli karo_rndbit0 :
#@cli : Randomize in [0..255] (byte) image$? bit level 0. wow randomize numbers to even and odd"
karo_rndbit0 :
  e[^-1] "Randomize in [0..255] (byte) image$? bit level 0." v -
  repeat $! l[$>] and 254 +rand 0,1 round. or endl done v +

#@cli karo_dtpread : filename,_bit0
#@cli : Read dtp image file format
#@cli :   (512 byte header, col[22-24] x row[25-27] byte image)
#@cli : with _bit0 != 0 bit level 1 is extracted as binary mask
#@cli :   and bit level 1 in the gray image is randomized with karo_rndbit0
#@cli : Ex.: karo_dtpread Images/Beispiele/tra005.cel,1
karo_dtpread : check isfile(['{/$1}']) check "${2=0}>=0"
  e[^-1] "Read dtp image file from "$1"." v -
  i raw:$1,uchar
  ({@22-24}) x={t} rm.
  ({@25-27}) y={t} rm.
  ({@0-79}) _dtph={t} rm.
  crop. 0,512,0,{h}
  resize. $x,$y,1,1,-1
  if $2
    +and. 1 karo_rndbit0..
  fi
  v +

#@cli _kr_ch2ch : number
#@cli : return alpha channel mode string from number in status.
#@cli : Ex. v - repeat 38 _kr_ch2ch \$\> echo_stdout \$\>,\${} done v +
#@cli : Ex. sp 0 repeat 38 +ac[0] \"blur 2%\",$>,2 _kr_ch2ch $> nm[$>] ${} done
_kr_ch2ch :
  if {isnum("$1")} if {isint("$1")}
    mode=${arg\ 1+$1,all,rgba,rgb,rgb_r,rgb_g,rgb_b,\
rgba_a,lrgb,lrgb_r,lrgb_g,lrgb_b,\
ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab_l,lab_ab,lab_a,lab_b,\
lch_ch,lch_c,lch_h,\
hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
yiq_y,yiq_iq,\
ryb,ryb_r,ryb_y,ryb_b}
    u $mode
  else u "$1" fi else u "$1" fi

#@cli region_feature : [labelimage],_region_label(1),_feature({wh})
#@cli : Return feature for a specified region in status.
#@cli : Selected image is unchanged, only one is evaluated.
#@cli : Argument '_feature' is a string that corresponds to the way the feature would
#@cli : be requested for the entire image in math. processor syntax without {}.
#@cli : $ image.jpg +luminance threshold. 50% label_fg. 0,1 v - echo_stdout "." \
# repeat 10 region_feature.. .,{$>+1},"ia,h" echo_stdout {$>+1},${} done
region_feature : check ${-is_image_arg\ $1} skip "${2=1} ${3="wh"} ${4=0}"
  e[^-1] "Calculate region feature(s) \"$3\" for label==$2 in "$1" from data$?."
  pass$1 l[-2,-1]
    +extract_region[0] [1],0,$2 rm[1]
    u {[$3]} rm.
  endl

#@cli karo_feat_eval_n : [maskimage],_high_connectivity,_oneo
#@cli : Compute features from selected transmission (grey) image and multi-component maskimage.
#@cli : if _oneo is true, mask is considered as one-component maskimage
#@cli : Features: centroid (x,y), area, mean extincton, sd extinction.
#@cli : follic_ loads an example image and mask
#@cli : $ follic_ karo_feat_eval_n.. . run "repeat {h#-2} =. 2,{i(#-2,0,$>)},{i(#-2,1,$>)} done" \
# +ge. 2 delaunay3d. n.. 0,255 j3d.. .,0,0,0,0.5,1 rm.
karo_feat_eval_n : check ${-is_image_arg\ $1} check "${2=1}>=0" skip ${3=0}
  e[^-1] "Compute features from transmission image$? and multi-component mask image "$1"."
  v -  repeat $! pass$1 0 l[$>,-1]
    if {!$3} +label_fg. 0,$2 else +neq. 0 fi
    mode=${"-_karo_mode... ,"} if {$mode<=160} mode={iM#-3} fi
    +karo_extinction... $mode
    l[-1,-2] o={iM#0} 6,$o
      repeat {iM#0}
        +eq[0] {$>+1} nn={is}
        +barycenter. cc0={@0} cc1={@1} rm.
        +*[1,-1] su={is/$nn}
        +. $su -sqr. *. [-2] su2={sqrt(is/($nn-1))}
        rm[-1--2]
        =. $cc0,0,$>
        =. $cc1,1,$>
        =. $nn,2,$>
        =. $su,3,$>
        =. $su2,4,$>
        =. $mode,5,$>
      done
    endl k.
  endl done v +

#@cli _karo_mode : _smooth(=5), low(=-1), hig(=-1), _binsize(=1), _nodel(=0)
#@cli : Estimate mode (most frequent value) of image histogram from selected image \
# after evtl. histogram smoothing between _low and _hig \
# with _low==-1 min and hig=-1 max from the image.
#@cli : If _binsize<0 it represents neg. number of cluster (classes)
#@cli : If _nodel==true the histogram is kept
_karo_mode :
  check ${1=5}>=0 skip "${2=-1} ${3=-1} ${4=1} ${5=0}"
	if {$2==-1} low={im} else low=$2 fi
	if {$3==-1} hig={iM} else hig=$3 fi
  if {$4<0} clust={abs($4)} binsize={($hig-$low)/$clust}
	else clust={round(($hig-$low+$4)/$4)} binsize=$4 fi
  if {$1>0} e[^-1] "Extract mode of image$? after smoothing $1 between "{_$low}" and "{_$hig}" binsize "$binsize" cluster "$clust
	else e[^-1] "Extract mode of image$? between "{_$low}" and "{_$hig}" binsize "$binsize" cluster "$clust fi
  +histogram. $clust,$low,$hig
  if {$1>0} smooth. $1 fi
  u {xM*$binsize+$low}
	if {!$5} rm. fi

#@cli descriptive_feature :
#@cli : Estimation of features number(sum,m0),mean(m1),SD(m2),skewness(m3),kurtosis(m4),min,max,median
#@cli : from skalar images.
#@cli : Ex. image.jpg to_gray descriptive_feature e \${}

descriptive_feature :
  e[^-1] "Calculate m0,m1,m2,m3,m4,min,max,med from data$?."
  v -
  repeat $! l[$>]
    if {s>1} v + e[^-1] "Data ["$>"] seemingly not skalar! Break!" v - continue fi
# Calculate features
    if {$_version>=216} res={"
      ff=stats(); ff[3]=sqrt(ff[3]); _(print(ff));
      m3=0;m4=0;for(ip=0,ip<whds,ip++,m3+=(i[ip]-ff[2])^3;m4+=(i[ip]-ff[2])^4);
      res=[whds,ff[2,2],m3/(whds*(ff[3])^3),m4/(whds*(ff[3])^4)-3,ff[0,2],ic()];
      _(print(res)); res"}
    else
      m0={whds} m1={ia} m2={sqrt(iv)} med={ic} mx={iM} mn={im}
      +- $m1 pow. 3 m3={is/($m0*$m2^3)} rm.
      +- $m1 pow. 4 m4={is/($m0*$m2^4)-3} rm.
      res=$m0\,$m1\,$m2\,$m3\,$m4\,$mn\,$mx\,$med
    fi
# Concatenate results for image list
      if {$>==0} sres=$res else sres=$sres\,$res fi
  endl done u $sres v +

#@cli example_descriptive_feature : [region],_all(false),_background(false),_verbose_draw(true),_verbose_text(false)
#@cli : Example for feature extraction from a selected grey image and a [region] mask or label image \
# using 'extract_region' and 'descriptive_feature'. More than 9 regions are truncated if _all == false. \
# Background region (label == 0) is only calculated if _background == true. \
# Graphical display of feature with _verbose_draw ==true and \
# textual display only with _verbose_text == true.
#@cli : The list of features is returned in status, \
# label,area,mean,SD,curtosis,excess,min,max,median \
# for each region.
#@cli : 'osteo_' and 'follic_' in the examples are transmission image examples from \
# microscopic cells with region masks
#@cli : $ osteo_ example_descriptive_feature.. . e ${}
#@cli : $ follic_ karo_extinction.. , label_fg. 0 example_descriptive_feature.. .
example_descriptive_feature :
  check ${"is_image_arg $1"}" && isbool(${2=0}) && isbool(${3=0}) && isbool(${4=1}) && isbool(${5=0})"
  pass$1 nm. Region
  im={im}
	if {$3==0&&$im==0} im+=1 fi
  num={iM-$im+1}
  fe="Area","Mean","SD","Curtosis","Excess","Min","Max","Median"
  m "_MC : $""=_M"
	st_ff=""
	nmax={$2?$num:9}
	if {$num>9&&$2==0} warn[0--3] "More than 9 regions! Not processed!" fi
  repeat $num,ii
    +extract_region[0] [1],0,{$im+$ii}
		if {h==0} rm. warn[0--3] "Empty region "{$im+$ii}"! Not processed!" continue fi
    descriptive_feature. rm. temp_ff=${} _MC ${}
		u {$im+$ii},$temp_ff temp_ff=${}
    if $4 128,128,1,3 text. "Features label: "{$im+$ii},0,0,12,1,255,255,0 fi
		if $5 e[] "Features label: "{$im+$ii} fi
    repeat 8
      ff=${arg\ {$>+1},$fe}\ =\ {_${_M{$>+1}}}
      if $5 e[] $ff fi
			if $4 text. $ff,0,{($>+2)*12},12,1,255,255,0 fi
    done
		if {${-strlen\ $st_ff}>0} st_ff=$st_ff,$temp_ff else st_ff=$temp_ff fi
		nmax-=1 if !$nmax break fi
  done rm[Region] uncommand _MC
  if $4 if {$num>3} append_tiles[1--1] 3 fi fi
	u $st_ff

#@cli karo_morpho : action, _kernel(0), _size(5), _ckernel("1,0,1; 0,1,0; 1,0,1")
#@cli : Mathematical morphology filter
#@cli : action={0=Ero | 1=Dil | 2=Open | 3=Close | 4=Ori-Ero | 5=Dil-Ori | 6=Ori-Open | 7=Close-Ori | \
# 8=(Ori*2-(Open+Close))*0.5 | 9=Close-Open}
#@cli : _kernel={0=Square | 1=Octogon | 2=Circle | 3=Custom}
#@cli : _size>=2(5)
#@cli : _ckernel (custom kernel only if _kernel==3)
#@cli : Derived from D Tschumperle's older fx_morpho (formerly gmic_stdlib) and extended by action 4..9
karo_morpho :
  skip "${2=0} ${3=5} ${4=1,0,1; 0,1,0; 1,0,1}"
  v - ac=Ero,Dil,Open,Close,"Ori-Ero","Dil-Ori","Ori-Open","Close-Ori","(Ori*2-(Open+Close))*0.5","Close-Open"
  ke=Square,Octagon,Circle,Custom v +
  e[^-1] "Math. morph. filter "${-arg\ {$1+1},$ac}" with kernel "${-arg\ {$2+1},$ke}" and size "$3 v -
  ({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ckernel={t} rm.
  if {$2==0} m "my_erode: erode $""1" m "my_dilate: dilate $""1"
  elif {$2==1} m "my_erode: erode_oct $""1" m "my_dilate: dilate_oct $""1"
  elif {$2==2} m "my_erode: erode_circ $""1" m "my_dilate: dilate_circ $""1"
  else
  m "my_erode : ("$ckernel") erode[^-1] . skip $""1"" rm."
  m "my_dilate : ("$ckernel") dilate[^-1] . skip $""1"" rm."
  fi
  if {$1==0} m "my_action : my_erode $3"
  elif {$1==1} m "my_action : my_dilate $3"
  elif {$1==2} m "my_action : my_erode $3 my_dilate $3"
  elif {$1==3} m "my_action : my_dilate $3 my_erode $3"
  elif {$1==4} m "my_action : +my_erode $3 -"
  elif {$1==5} m "my_action : +my_dilate $3 rv -"
  elif {$1==6} m "my_action : +my_erode $3 my_dilate. $3 -"
  elif {$1==7} m "my_action : +my_dilate $3 my_erode. $3 rv -"
  elif {$1==8} m "my_action : +my_erode $3 my_dilate. $3 +- rm.. +my_dilate.. $3 my_erode. $3 \
rv[-1,-3] -[-1,-3] rv - / 2"
  elif {$1==9} m "my_action : +my_erode $3 my_dilate. $3 my_dilate.. $3 my_erode.. $3 -"
  else m "my_action : +my_dilate $3 my_erode. $3 rv -"
  fi
  repeat $! l[$>]
  my_action[0]
  endl done
  uncommand my_erode,my_dilate,my_action
  v +

#@cli fx_karo_mm_diff : _size,_size2,_operation,_shape,_channel,_scale
#@cli : Compute difference of math. morph. operation with two sizes on selected images.
#@cli : _size = int(5,1,25)
#@cli : _size2 = int(7,1,25)
#@cli : _operation = choice(2,"Erosion","Dilation","Open","Close")
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@cli :  "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@cli :  "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@cli :  "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@cli :  "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@cli :  "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@cli :  "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@cli : _scale = bool(true)
##@cli : Best with odd sizes!
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2019/09/03</i>.
fx_karo_mm_diff :
  skip "${1=5}","${2=7}","${3=2}","${4=1}","${5=0}","${6=1}"
  if {$2<=$1} s2={$1+2} else s2=$2 fi
  karo_doo $1,${s2},$3,$4,$6,$5
  to_rgb

fx_karo_mm_diff_preview :
  gui_split_preview "-fx_karo_mm_diff ${1-6}",${-3--1}

#@cli fx_karo_cimg_nlmeans : add_Gauss_noise(0),add_uniform_noise(0),add_salt_pepper(0),\
# patch_size(0),lambda(-1),noise_sd(-1),alpha(3),steps(2)
#@cli : Execute use_nlmeans (CImg demo) external.
fx_karo_cimg_nlmeans :
  skip "${1=0}","${2=0}","${3=0}","${4=1}","${5=-1}","${6=-1}","${7=3}","${8=2}"
  karo_nlmeans -ng,$1,-nu,$2,-ns,$3,-p,$4,-lambda,$5,-sigma,$6,-alpha,$7,-sampling,$8

fx_karo_cimg_nlmeans_preview :
  gui_split_preview "-fx_karo_cimg_nlmeans ${1-8}",${-3--1}

#@cli fx_karo_cimg_skel : auto_thresh(1),thresh(50%),median(0),invert(0),thresh_flux(-0.3),\
# medial_curve(0),Torsello corr(0),steps(1)
#@cli : Execute use_skeleton (CImg demo) external.
fx_karo_cimg_skel :
  skip "${1=1}","${2=50}","${3=0}","${4=0}","${5=-0.3}","${6=0}","${7=0}","${8=1}"
  if $1 otsu 256 else threshold ${2}% fi
  karo_skeleton median,$3,-inv,$4,-t,$5,-curve,$6,-corr,$7,-dlt,$8 n 0,255

fx_karo_cimg_skel_preview :
  gui_split_preview "-fx_karo_cimg_skel ${1-8}",${-3--1}

#@cli fx_karo_oc_diff : _size,_shape,_channel,_scale
#@cli : Compute difference of math. morph opening and closing on selected images.
#@cli : _size = int(5,1,25)
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@cli :  "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@cli :  "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@cli :  "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@cli :  "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@cli :  "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@cli :  "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@cli : _scale = bool(true)
##@cli : Best with odd sizes!
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2019/09/03</i>.
fx_karo_oc_diff :
  skip "${1=5}","${2=1}","${3=0}","${4=1}"
  apply_channels "-karo_doc $1,$2,0",$3,$4
  to_rgb

fx_karo_oc_diff_preview :
  gui_split_preview "-fx_karo_oc_diff ${1-4}",${-3--1}

#@cli fx_karo_pink : _operator(=11), _connect(=0), _smooth(=0), _param(=5), _channel(=0)
#@cli : _operator = 0..19 ("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima",\
# "grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg",\
# "dilatballnum","erosballnum","lintophat")
#@cli : _connect = 0..1 ("Four/x","Eight/y")
#@cli : _smooth = 0..
#@cli : _param = 0..25
#@cli : _channel = choice(0,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",\
# "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",\
# "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",\
# "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",\
# "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",\
# "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",\
# "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@cli : $ image.jpg +fx_karo_pink , +-
#@cli : $ image.jpg +fx_karo_pink. 12,1,0.582524,10,0,0 +fx_pink.. 12,0,0.582524,10,0,0 +[-1,-2] # asflin in x and y
fx_karo_pink :
  skip ${1=11},${2=0},${3=0},${4=5},${5=0}
  coms="pink heightminima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4}",\
       "pink heightmaxima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4},i",\
       "pink minima,{($2+1)*4}",\
       "pink maxima,{($2+1)*4}",\
       "pink heightminima,{($2+1)*4},$4",\
       "pink heightmaxima,{($2+1)*4},$4",\
       "pink grayskel,null,4,$4",\
       "pink htkern,null,{($2+1)*4}",\
       "pink htkernu,null,{($2+1)*4}",\
       "pink lvkern,null,{($2+1)*4}",\
       "pink lvkernu,null,{($2+1)*4}",\
       "pink asf,$4",\
       "[0]x2 a z if {$2==0} pink asflin,x,$4 else pink asflin,y,$4 fi s z k.",\
       "pink asfr,$4",\
       "pink asft,null,null,{($2+1)*4},$4",\
       "pink asftmed,{($2+1)*4},$4",\
       "pink asftndg,null,null,{($2+1)*4},$4",\
       "pink dilatballnum,$4",\
       "pink erosballnum,$4",\
       "pink lintophat,$4"
  if {$1>=0&&$1<20} arg {$1+1},$coms else arg 1,$coms} fi com=${}
#	echo_stdout $com
  if {$3>0} apply_channels "b $3 round "$com,$5,0 else  apply_channels "round "$com,$5,0 fi

fx_karo_pink_preview :
  gui_split_preview "-fx_karo_pink ${^0}",${-3--1}

fx_karo_pink_bin :
  skip ${1=1},${2=50},${3=3},${4=0},${5=5},${6=4},${7=0}
  coms="_skelpar $6,$5",\
       "_skelend {($4+1)*4},$5",\
       "_skelcurv $6,{($4+1)*4}",\
       "_skeleton $6,{($4+1)*4}",\
       " barycentre,{($4+1)*4}",\
       " border,{($4+1)*4}",\
       " closeball,$5,$6",\
       " openball,$5,$6",\
       " convexhull,3",\
       " dist,$6",\
       " distc,$6",\
       " label,{($4+1)*4},pla",\
       " lantuejoul,$6"
  if {$3>=0&&$3<13} arg {$3+1},$coms else arg 1,$coms} fi com=${}
#	echo_stdout $com
  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink"$com" n 0,255",$7,0

fx_karo_pink_bin_preview :
  gui_split_preview "-fx_karo_pink_bin ${^0}",${-3--1}

#@cli fx_karo_pink_bianca : Pink test operator bianca
#@cli : ASF smooth size = int(5,1,10)
#@cli : Threshold (%) = int(60,0,100)
#@cli : Watershed height min = int(5,0,20)
#@cli : Opening radius = int(1,0,10)
#@cli : Invert = bool(0)
#@cli : Use G instead of B = bool(0)
#@cli : Pink test operator Bianca for RGB image; only B used.
#@cli : Pink executables in search PATH or C:\\Pink\\bin\\ for Windows
#@cli : Author : <i>KaRo</i>.           Latest update : <i>2012/11/18</i>
#@cli : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_karo_pink_bianca : 
  skip "${1=5}","${2=60}","${3=5}","${4=1}","${5=0}","${6=0}"
  if $5 negate fi
  if {!${-is_windows}} exe="label" else exe="C:\Pink\bin\label" fi
  s c if $6 k.. else k. fi
#	+round -. .. e {is} rm.
  +round
  pink asf,$1 +- k[-1,-3] threshold. $2%
  +pink_wshed.. ,1,$3
  pink. $exe,4,max threshold. 1
  erode_oct.. {$4*2+1} dilate_oct.. {$4*2+1}
  +*[-1,-2] negate.. n[-1,-2] 0,255 a[-1,-2,-4] c k[0]

fx_karo_pink_bianca_preview :
  gui_split_preview "-fx_karo_pink_bianca ${^0}",${-3--1}

#@gui CImg Skeleton : fx_karo_cimg_skel, fx_karo_cimg_skel_preview(0)
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold (%) = float(50,0,100)
#@gui : Size Median = int(0,0,15)
#@gui : Invert = bool(false)
#@gui : Threshold on Flux = float(-0.3,-5,5)
#@gui : Medial Curve = bool(false)
#@gui : Torsello Correction =bool(false)
#@gui : Discrete Step = int(1,1,15)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note(Skeleton using CImg example plugin use_skeleton.)
#@gui : note = note{"CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")

#@gui CImg NL-Means : fx_karo_cimg_nlmeans, fx_karo_cimg_nlmeans_preview(0)
#@gui : Add Gauss Noise = float(0.0,0.0,30.0)
#@gui : Add Uniform Noise = float(0.0,0.0,30.0)
#@gui : Add Salt & Pepper Noise = float(0.0,0.0,30.0)
#@gui : Half Size of Patch = int(1,1,15)
#@gui : Band Width Lambda = float(-1,-1,25)
#@gui : Noise SD Sigma = float(-1,-1,25)
#@gui : Neighborhood Size Alpha = int(3,1,15)
#@gui : Sampling Step Size = int(2,1,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note(Smoothing using CImg example plugin use_nlmeans.)
#@gui : note = note{"CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2019/09/03</i>.</small>")

#@gui mM Differences : fx_karo_mm_diff, fx_karo_mm_diff_preview(0)
#@gui : Size = int(5,1,25)
#@gui : Size2 = int(7,1,25)
#@gui : Operation = choice(2,"Erosion","Dilation","Open","Close")
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui : Scale = bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
##@gui : Best with odd sizes!
#@gui : sep = separator(), note = note("Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")

#@gui OC Differences : fx_karo_oc_diff, fx_karo_oc_diff_preview
#@gui : Size = int(5,2,25)
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui : Scale =bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
##@gui : Best with odd sizes!
#@gui : sep = separator(), note = note("Difference of mean of morphological opening and closing with original.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2013/07/04</i>.</small>")

#@gui Pink Test Operator Bianca: fx_karo_pink_bianca, fx_karo_pink_bianca_preview(0)
#@gui : ASF Smooth Size = int(5,1,10)
#@gui : Threshold (%) = int(60,0,100)
#@gui : Watershed Height Min = int(5,0,20)
#@gui : Opening Radius = int(1,0,10)
#@gui : Invert = bool(0)
#@gui : Use G Instead of B = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note(Pink test operator Bianca for RGB image; only B used.)
#@gui : note = note{"Pink executables in search PATH or C:\\Pink\\bin\\ for Windows"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           \
# Latest update : <i>2012/10/26</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")

#@gui Pink Operator : fx_karo_pink, fx_karo_pink_preview
#@gui : Pink Operator = choice("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Smoothness = float(0,0,5)
#@gui : Height/Rep = int(5,0,25)
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")

#@gui Pink Operator Binary: fx_karo_pink_bin, fx_karo_pink_bin_preview
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold (%) = int(50,0,100)
#@gui : Pink Operator = choice(3,"skelpar","skelend","skelcurv","skeleton","barycentre","border","closeball","openball","convexhull","dist","distc","label pla","Lantuejoul")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Height/Rep = int(5,-1,25)
#@gui : Algorithm = int(4,0,29)
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note(Binary operations with Pink externals.)
#@gui : note = note{"Diverse Pink executables in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2014/02/05</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")

#@gui _

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
