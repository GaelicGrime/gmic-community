#@gmic
#
#  File        : joan_rake1.gmic
#                ( G'MIC commands file )
#
#  Description : Personal G'MIC filters done by Ronounours and others.
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#@gui _<b>Degradations</b>
#---------------------------

#@gui UltraWarp+++ : fx_ultrawarpplusplusplus, fx_ultrawarpplusplusplus(1)
#@gui : note = note("Sequence of multiple partially-randomised texture generation and image deformation filters with multi-iteration warping")
#@gui : note = note("<small>This modular filter is extremely complex and its logic may not follow that which you expect. Left on its default settings, it is very likely to munge your image beyond recognition.</small>"), sep = separator()
#@gui : 1.  Quick Refresh Button = bool(0)
#@gui : sep = separator()
#@gui : 2.  Plasma Texture [Discards input image] = bool(0)
#@gui : 3.  Plasma Scale = float(3.3,0,20)
#@gui : 4.  Plasma Alpha Channel = bool(0)
#@gui : sep = separator()
#@gui : 5.  Segmentation [no alpha channel] = bool(1)
#@gui : 6.  Edge Threshold = float (20,0.01,60)
#@gui : 7.  Smoothness = float (0,0,60)
#@gui : sep = separator()
#@gui : 8.  Blur = float (0,0,30)
#@gui : sep = separator()
#@gui : 9.  Quadtree Pixelisation [no alpha channel] = bool(1)
#@gui : 10.  Quadtree Min Precision = int(4,2,2048)
#@gui : 11.  Quadtree Max Precision = int(256,0,2048)
#@gui : 12.  Quadtree Min Homogeneity = float(4.8,0,5)
#@gui : 13.  Quadtree Max Homogeneity = float(5,0,5)
#@gui : sep = separator()
#@gui : 14. Noise Type = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : 15. Minimum Noise = float(0,0,8)
#@gui : 16. Maximum Noise = float(0,0,8)
#@gui : 17. Noise Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Warping</small>")
#@gui : 18. Warp Iterations = int(5,0,30)
#@gui : 19. Warp Intensity = float(2.8,0,30)
#@gui : 20. Warp Offset = float(10,0,2000)
#@gui : 21. Scale to Width = bool(1)
#@gui : 22. Scale to Height = bool(1)
#@gui : 23. Correlated Channels = choice("Random","Off","On")
#@gui : 24. Warp Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 25. Random Negation = bool(1)
#@gui : 26. Random Negation Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 27. Gamma Offset = float(0.25,0,1)
#@gui : 28. Hue Offset = float(1,0,1)
#@gui : 29. Normalise = bool(1)
#@gui : sep = separator(), note = note("<small>Final HSV Scaling</small>")
#@gui : 30. Minimum Hue = float(0,0,20)
#@gui : 31. Maximum Hue = float(5,0,20)
#@gui : 32. Minimum Saturation = float(0,0,20)
#@gui : 33. Maximum Saturation = float(3,0,20)
#@gui : 34. Minimum Value = float(0,0,20)
#@gui : 35. Maximum Value = float(20,0,20)
#@gui : note = note("<small>Set these to their minimum values for randomisation</small>")
#@gui : 36. Hue Offset = float(-180.01, -180.01, 180)
#@gui : 37. Saturation Offset = float(-0.01, -0.01, 1)
#@gui : 38. Value Offset = float(-20.01,-20.01,20)
#@gui : sep = separator(),
#@gui : -3. Normalise = bool(1)
#@gui : -2. Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : -1. Value action = choice("None","Cut","Normalize")

ultrawarpplusplusplus:

# plasma rendering and pixelisation followed by random warp with gamma and hue randomisation and final HSV scaling

  hue_min={$30}
  hue_max={$31}
  sat_min={$32}
  sat_max={$33}
  val_min={$34}
  val_max={$35}

  j={min($hue_min,$hue_max)+(u*(max($hue_min,$hue_max)-min($hue_min,$hue_max)))}
  k={min($sat_min,$sat_max)+(u*(max($sat_min,$sat_max)-min($sat_min,$sat_max)))}
  l={min($val_min,$val_max)+(u*(max($val_min,$val_max)-min($val_min,$val_max)))}

  -if {$2}

    -if {$4} ch=0 -else ch=2 -endif

    -ac  "rr={round(u*255)}
          gg={round(u*255)}
          bb={round(u*255)}

          -fx_plasma 0.5,0,{$3},1,1,{$rr},{$gg},{$bb}
          -if {$4} -to_rgba -else ch=2 -to_rgb -endif",{$ch}

  -endif

  -fx_gaussian_blur {$8},0,0,1,2,0,0

  n_min={$15}
  n_max={$16}

  -if {$n_min > $n_max}
    n_min = {$n_min + $n_max}
    n_max = {$n_min - $n_max}
    n_min = {$n_min - $n_max}
  -endif

  noise_exp={max(0,$n_min+(u*($n_max-$n_min)))}
  n_amt={4^($noise_exp-3)-((4^(-3))*($noise_exp-1))}

  -if {$5}
    -fx_segment_watershed {$6},{$7},0,2,0
  -endif
  -if {$9}

    p_min={$10}
    p_max={$11}
    h_min={$12}
    h_max={$13}

    -if {$p_min > $p_max}
      p_min = {$p_min + $p_max}
      p_max = {$p_min - $p_max}
      p_min = {$p_min - $p_max}
    -endif

    -if {$h_min > $h_max}
      h_min = {$h_min + $h_max}
      h_max = {$h_min - $h_max}
      h_min = {$h_min - $h_max}
    -endif

    -fx_noise {$noise_exp},{$14},{$17},1,0
    -fx_quadtree 0,{max(2,round($p_min+(u*($p_max-$p_min))))},{max(0,round($h_min+(u*($h_max-$h_min))))},0,3,1.5,1,1,0

  -endif

  -fx_noise {$noise_exp},{$14},{$17},1,0

  f={$18} # iterations
  i={$19} # warp intensity
  m={$20} # offset magnitude
  s={$27} # gamma
  v={$28} # hue

  -repeat {max(0,$f)}

    -if {$21}
      scale_x=w/100
    -else
      scale_x=1
    -endif
    -if {$22}
      scale_y=h/100
    -else
      scale_y=1
    -endif

    a=(u-0.5)*$i
    b=(u-0.5)*$i
    c=(u-0.5)*$m*sign($m)*$scale_x
    d=(u-0.5)*$m*sign($m)*$scale_y
    f={round((u*2.98)+0.51)}
    g={round((u*33.98)-0.49)}
    h={(u-0.5)*$s*200}
    o={(u-0.5)*$v*200}

    -if {$23==1}
      e=0
    -elif {$23==2}
      e=1
    -else
      e={round(u)}
    -endif

    -if {$24==0}
      -fx_warp_by_intensity {$a},{$b},{$c},{$d},{$e},0,{$f},{$g},0
    -else
      -ac  "-if {$21}
              scale_x=w/100
            -else
              scale_x=1
            -endif
            -if {$22}
              scale_y=h/100
            -else
              scale_y=1
            -endif
            a={(u-0.5)*$19}
            b={(u-0.5)*$19}
            c={(u-0.5)*$20*sign($20)*$scale_x}
            d={(u-0.5)*$20*sign($20)*$scale_y}
            f={round((u*2.98)+0.51)}

            -if {$23==1}
              e=0
            -elif {$23==2}
              e=1
            -else
              e={round(u)}
            -endif

         -_fx_warp_by_intensity {$a},{$b},{$c},{$d},{$e},0,{$f}",{$24},0
    -endif


    -if {$25}
      nn={round(u)}
      -if {$nn}
        -if {$26==0}
          nch={round((u*33.98)-0.49)}
          -ac "-negate",{$nch}
        -else
          -ac "-negate",{$26}
        -endif
      -endif
    -endif

    -fx_adjust_colors 0,0,{$h},{$o},0,0

    -if {$29}
      -ac "-n 0,255",3
    -endif

  -done

  -if {$36==-180.1}
    hh=((u-0.5)*360)
  -else
    hh={$36}
  -endif
  -if {$37==-0.01}
    ss=((u-0.5)*2)
  -else
    ss={$37}
  -endif
  -if {$38==-20.01}
    vv=((u-0.5)*2)
  -else
    vv={$38}
  -endif

  -fx_mix_hsv {$j},{$hh},0,{$k},{$ss},0,{$l},{$vv},0,0,2,0

  -if {$-3}
    -ac "-n 0,255",3
  -endif

fx_ultrawarpplusplusplus:

index=0
layers=l

-repeat {max(0,$layers)}
  -ac[$index] "-ultrawarpplusplusplus $*",$-2,$-1
  -fx_adjust_colors[$index] 0,0,0,{(u-0.5)*200},0,0
  index={$index+1}
-done


#@gui _<b>Testing</b>
#---------------------

#@gui <i>Joan Rake</i>

#@gui Cascading self glitching: fx_self_glitching_cascade, fx_self_glitching_cascade_preview(1)
#@gui : Channels = choice("RGB","CMY","CMYK","HSV","HSL","HSI","LCH","YCbCr","YIQ","YUV","HCY","Bayer")
#@gui : Alpha Glitch = bool(0)
#@gui : Zeroth shift = point(50,50)
#@gui : Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : Iterations = int(3,1,10)
#@gui : Power = float(0,-5,5)
#@gui : Bias = float(0,-255,255)
#@gui : Negate = bool(0)
#@gui : Operator = choice("Add","Multiply","Bitwise And","Bitwise Or","Bitwise Xor","Power","Reverse Power","Modulo","Reverse Modulo","Divide","Reverse Divide","Subtract","Reverse Subtract","Left Bitwise Shift", "ReverseLBS", "Right Bitwise Shift", "ReverseRBS","Average","Round","Reverse Round","Sine","Reverse Sine","Cosine","Reverse Cosine","Tangent &#40;CPU-intensive&#41;","Reverse Tangent &#40;CPU-intensive&#41;")
#@gui : First shift target = point(50,50)
#@gui : Cascade centre point = point(50,50)
#@gui : Shift randomness = float(0.75,0,4)
#@gui : Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Joan Rake</i>.      Latest update: <i>2018/08/21</i>.</small>")
fx_self_glitching_cascade :
shift {$3-50}%,{$4-50}%,0,0,$5,0
repeat $6
repeat $! l[$>] if {!$2} split_opacity fi l[0]
if {$1==1} rgb2cmy elif {$1==2} rgb2cmyk elif {$1==3} rgb2hsv elif {$1==4} rgb2hsl elif {$1==5} rgb2hsi elif {$1==6} rgb2lch elif {$1==7} rgb2ycbcr elif {$1==8} rgb2yiq elif {$1==9} rgb2yuv elif {$1==10} rgb2hcy elif {$1==11} rgb2bayer 0 fi
f "init(
shift = ([w,h]-1)*([$13,$14]-[$11,$12]+(2*(u-0.5)*sqrt((($13-$11)^2)+(($14-$12)^2))*($15^3)))%;
const sign = $9?-1:1;
const boundary = $16;
);
val = sign*((2^$7)*j(shift) + $8);
($10==0?(val + i):
$10==1?(val * i):
$10==2?(val & i):
$10==3?(val | i):
$10==4?xor(val,i):
$10==5?(val^i):
$10==6?(i^val):
$10==7?(val%i):
$10==8?(i%val):
$10==9?(val / i):
$10==10?(i / val):
$10==11?(i - val):
$10==12?(val - i):
$10==13?(val << i):
$10==14?(i << val):
$10==15?(val >> i):
$10==16?(i >> val):
$10==17?avg(i,val):
$10==18?round(val,i,0):
$10==19?round(i,val,0):
$10==20?i*sin(val*2*pi/255):
$10==21?val*sin(i*2*pi/255):
$10==22?i*cos(val*2*pi/255):
$10==23?val*cos(i*2*pi/255):
$10==24?(i*tan(val*pi/255)):
(val*tan(i*pi/255))
)%255;
"
if {$1==1} cmy2rgb elif {$1==2} cmyk2rgb elif {$1==3} hsv2rgb elif {$1==4} hsl2rgb elif {$1==5} rgb2hsi elif {$1==6} lch2rgb elif {$1==7} ycbcr2rgb elif {$1==8} yiq2rgb elif {$1==9} yuv2rgb elif {$1==10} hcy2rgb elif {$1==11} bayer2rgb 0,0,0 fi
endl a c endl done done
fx_self_glitching_cascade_preview :
fx_self_glitching_cascade $*

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
