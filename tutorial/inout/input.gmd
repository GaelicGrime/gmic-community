# input (i)
%% x "mkdir -p img" %%
|![hollerith](images/hollerith.png) *A [Hollerith Tabulating Machine](https://www.census.gov/history/www/innovations/technology/the_hollerith_tabulator.html), 1890 United States Census. [Computer History Museum](https://en.wikipedia.org/wiki/Computer_History_Museum), Mountain View, CA, United States of America. Jennifer, Wikimedia Commons*|''-input'' is the least written, most frequently used command in the G'MIC scripting language.  It places images from some source to one or more positions on the image list, creating the list if necessary, and duplicating as necessary. The command's [image selection decorator](https://gmic.eu/tutorial/command_decorations.html) designates the positions where the incoming image goes in the image list; the incoming image goes _before_ the images enumerated in the selection decorator and is copied as necessary.

It is unique among G'MIC commands in that ''-input'' has an implied (invisible) shortcut. If the G'MIC command parser cannot associate an item with a command or a parameter then it infers that the ''-input'' command precedes the item, classifying the item itself as a parameter to the ''-input'' command. The parser then passes the (presumed) image to this command for processing.

To make best use of the ''-input'' command, become familar with the five variations that the input argument can take and how the command interprets its right hand selector decoration. Very broadly, the input argument, in one of four forms, specifies the source images. The right hand selecton decorator, if present, specifies their destination. The ''-input'' command must have a source specification. The destination is optional and if omitted implies an insertion point to the right of the last position on the list.

## Source Specifications
= input_specifications
[Input Data Items](https://gmic.eu/reference/input_data_items.html#top) furnishes a terse, but complete list of methods which ''-input'' employs to sort out images from other command line riff-raff. There are six broad approaches, many with variants.

= 
|1.  | __File and File-like Sources__: ''-input'' always works with local file system sources. It can also work with hypertext resource locators so long as the underlying operating system offers [wget-](https://man7.org/linux/man-pages/man1/wget.1.html) or [curl-](https://man7.org/linux/man-pages/man1/curl.1.html) like capabilities. The item either identifies a local file, with, possibly, a path preceding the filename, the entire construct written according to the operating system's rules for identifying files, or – with `wget` or `curl` present – a Uniform Resource Locator (URL) identifying an image somewhere on the Internet. In this case, ''-input'' will initiate an HTTP request to retrieve the image via the Hypertext Transfer Protocol. __Selections and Multipliers:__ As with other commands, ''-input'' may take a right hand selection decorator, but in this case, the selector indicates positions where the incoming imagery may be inserted, creating as many copies as necessary. Positive selectors position new imagery to the _left_ of indicated positions; negative selectors position new imagery to the _right_ of indicated positions. Unlike other commands, which default without selection decorators, ''-input'' has a default of `[-1]`. Without an explicit decorator, ''-input'' places new imagery to the right of the last image on the list. Multiplier notation `x<_N_>` for a positive integer `N` places N copies of incoming imagery in each indicated position. __Image Type Overrides:__ One may override file extensions, which imply certain image types, with explicit left hand type declarations.   

===
%% -input https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Lullwater_south_from_Binnen-Bridge_Prospect_Park.jpg/640px-Lullwater_south_from_Binnen-Bridge_Prospect_Park.jpg %%
*The Lullwater, Prospect Park, Brooklyn NY, c. 5 June, 2005. From Wikimedia Commons*
===

* Put an image of Prospect Park's Lullwater on the end of the image list, creating the image list, if necessary.
===
~~~
gmic -input https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Lullwater_south_from_Binnen-Bridge_Prospect_Park.jpg/640px-Lullwater_south_from_Binnen-Bridge_Prospect_Park.jpg 
~~~
===

* Put two copies of `hollerith.png` from the `images` directory before the first image on the image list.
===
~~~
gmic -input images/fish.jpg -input[0]x2 images/hollerith.png
~~~
===

* Declare an incoming image to be of a specific type, without regard to the filename or its extension. If the type specification is wrong, G'MIC will attempt to fall back to its own determination of an image type. If the fallback fails, G'MIC will post an error.   
===
~~~
gmic -input jpg:images/hollerith.png
~~~
===

* Use `-`, with an optional trailing type specifier, to load an image from the shell's input stream. Here is an overly obtuse way in a bash shell to input an image from a file:  
~~~
cat images/hollerith.png | gmic -.png
~~~
===

 *§§§*


===
= 
|2.  | __Image Dimensions, With and Without Math Expressions__: The command line item is an image specification, a set of up to five parameters, separated by commas that collectively specify a new image and, possibly, its content through a mathematical expression. __Absolute Sizing:__ The first four parameters are literal numerals that list the new image's width, height, depth (number of slices), and spectrum (number of channels). Except for the first, the second through fourth parameters are optional and may be omitted; omitted dimensions default to one pixel. The fifth parameter is also optional and may express a [Mathematical Expression](https://gmic.eu/reference/mathematical_expressions.html#top) which computes content on the fly. __Relative Sizing:__ Percentages may be employed to cite dimensions relative to the preceding image on the list. If there is no previous image on the list, dimensions default to one.

===
%% -input 128,128,1,3,'c==0?x%17:c==1?x%7:x%11' -normalize. 0,255 -name stripes %%
 *Stripes, any way you want them.*
===
* Input an image through specified image dimensions and fill with a math expression.
===
~~~
gmic -input 128,128,1,3,'c==0?x%17:c==1?x%7:x%11' -normalize. 0,255 -name stripes
~~~
===
* Input a one pixel image. This form implicitly invokes the ''-input'' command and the remaining three dimensions default to 1.
===
~~~
gmic 1
~~~
%% -input 128,128,1,3,'[255,0,63]' -input 60%,80%,100%,100%,[63,0,255]  %%
 *Red and blue*
===
* Input a reddish image with absolute dimensions; a math expression denoting a single reddish pixel fills the entire image. Input a second bluish image with dimensions relative to the first.
~~~
gmic -input 128,128,1,3,'[255,0,63]' -input 60%,80%,100%,100%,[63,0,255]
~~~
===

*§§§*


===
= 
|3.  | __Selectors__: A selector designation occuring in isolation functions as an implicit copy command. __Dimensions from Decorators:__ Selectors may also be used to specify particular dimensions taken from other images. In the latter case, copying of image content does not take place, just image dimensions. Use commas between decorators.
===

%% -input images/fish.jpg -r2dx. 50%,5 [-1] -r2dx. 50%,5 %%
 * New Orleans fish, by whole and by half. c. 1995 *
===
* Input an image. Shrink it by half. Make a copy. Shrink that by half again.
~~~
gmic -input images/fish.jpg -r2dx. 50%,5 [-1] -r2dx. 50%,5
~~~
===

%%  -input images/usdoj_1892.jpg -r2dx. 50%,5 [-1] -r2dx. 50%,5 [-2],[-1],[-2],[-1],'[255,220,75]' %%
 *  Paperwork with yellow *
===
* Input an image. Shrink it by half (twice). Make a yellowish image with mixed dimensions from the preceding images.
~~~
gmic -input images/usdoj_1892.jpg -r2dx. 50%,5 [-1] -r2dx. 50%,5 [-2],[-1],[-2],[-1],'[255,220,75]'
~~~
===

 *§§§*


===
= 
|4.  | __Prescribed Values__: The command line item is a formatted data stream. Almost always, this variation is not how humans specify images, except, perhaps for tiny data sets useful for expanding into colormaps. Suppose you write an image generator and it starts a G'MIC interpretor in a child process. Your image generator could output the entire command line for the child process, starting with 'gmic' and including an image stream as a command line parameter. Your script does not have to know a great deal about how G'MIC works. It only needs to be able to write images streams by these rules:

1. Since an image stream is, above all, a command line item, it cannot embed whitespace anywhere.
2. The stream starts with an open parenthesis, (, and finishes with a closed parenthesis.) '()' is disallowed. Something must appear between the parentheses.
3. Between parentheses, the stream consists of at least an initial floating point numeral.
4. This initial floating point numeral necessarily occupies column x=0, row y=0, slice z=0 and channel c=0.
5. If the next character is the closing parenthesis, then a complete, though very small, image has been fully specified. It has one column, row, slice and channel and consists of one pixel. That pixel's intensity is equal to the floating point numeral.
6. If the image is to be larger than one pixel, then the next item will be one of four delimiters, each structuring the overall shape of the image in particular ways. These delimiters are: (i) Commas (*,*) which separate and link runs of pixels into columns, (ii) semicolons (*;*), which separate and link runs of columns into rows. (iii) carets (*^*) which separate and link blocks of columns and rows into channels, and (iv) slashes (*/*) which separate blocks of columns and rows stacked as channels into slices.
7. Once the interpreter receives the closing parenthesis, it can infer the image's dimensions:
   a. The column count comes from the longest contiguous run of commas, plus one. If there are no commas anywhere in the stream, the image has one column.
   b. The row count comes from the longest run of semicolons unbroken by carets or slashes, plus one. If there are no semicolons anywhere in the stream, the image has only one row.
   c. The channel count comes from the longest run of carets unbroken by slashes, plus one. If there are no carets anywhere in the stream, the image has only a single channel.
   d. The slice count comes from the total number of slashes in a stream, plus one. If there are no slashes anywhere in the stream, the image has only one slice.
8. This scheme allows one to specify only as much of an image as needed. Omitted entries default to pixels with zero value. That is, columns, rows, or channels with insufficient elements are padded as needed with zero so that all runs of a particular delimiter class equals the largest one observed in the stream.

===
%% (240,200,150^200,130,46^0,180,23) r2dx. 256,5 %%
 * A 256 colormap made from a tiny, 3,1,1,3 image *
===
* Input a three by one pixel RGB image and expand it into a color map. 
~~~
gmic  (240,200,150^200,130,46^0,180,23) r2dx. 256,5
~~~
===
%% (0,0,0,255;0,0,0,255;0,0,0,255;255,255,255,255,255,255,255;0,0,0,255;0,0,0,255;0,0,0,255) r2dx. 49,1 %%
 *A 7 × 7 white cross on a black field*
===
* Input a 7 × 7 white cross on a black field. Instead of specifying all 49 pixels, let many default to black
~~~
gmic (0,0,0,255;0,0,0,255;0,0,0,255;255,255,255,255,255,255,255;0,0,0,255;0,0,0,255;0,0,0,255)
~~~
===

 *§§§*


===
= stringimages
|5.  | __Strings__: The command line item is a single-quoted string within parentheses. Optionally, the single-quoted string may be followed by a colon and a single-character delimiter code. Also optionally, multiplier notation `x<_N_>` for a positive integer `N` may follow the parentheses, placing N consecutive copies of the image in the list. Thus: ('string'[:delimiter])[xN]: Insert one or N new images from specified string, by filling the images with the character codes composing the string. __Delimiters:__ When specified, delimiter tells about the main orientation of the image. Delimiter can be 'x' (eq. to , which is the default), 'y' (eq. to ;), 'z' (eq. to /) or 'c' (eq. to ^).
===
%% -input ('bubbaboy') -r2dy 32,1 %%
 * \'bubbaboy\' *
===
* Input a sinqle-quoted string. Pel values equal the character code. The pel in channel zero, column zero and row zero is decimal 98, hexadecimal 0x62, the character code for lowercase 'b' in UTF-8. 
~~~
gmic  -input ('bubbaboy') 
~~~
===
%% -input ('columnvector':y) -r2dx 32,1 %%
 * A column vector *
===
* Input a column vector.
~~~
gmic -input ('columnvector':y)
~~~
===
%% -input ('boy':c) -r2dx 32,1 %%
 * One pale blue pixel *
===
* Input a sinqle pale blue pixel, equivalent to -input 1,1,1,3,[98,111,121].
~~~
gmic  -input ('boy':c)
~~~
===

 *§§§*


===
= storedimages
|6.  | __Stored Images__: The command line item is an image previously committed to off-list storage via the [-store](https://gmic.eu/tutorial/store.html) command.

===
%%  images/hollerith.png -r2dx 50%,5 -store smallcounter -repeat 5 -input $smallcounter -adjust_colors. 0,0,0,{20*$>} -done -append x %%
 * Step through the hue parameter five times, +20 per step.  *
===

* Investigate the behavior of the ''-adust_colors'' hue parameter with a five-step sampler
~~~
gmic -input images/hollerith.png -r2dx 50%,5 -store smallcounter -repeat 5 -input $smallcounter -adjust_colors. 0,0,0,{20*$>} -done -append x
~~~

= emptyimages
|7.  | __Empty Images__: The command line item is an image without any rows, columns, channels or slices. Not a black image; more like a "void" image. Because of this remarkable condition, the image could provide stop conditions at the end of a list of otherwise "real" images.

>          `[gmic]-0./ Start G'MIC interpreter.                          `
>          `[gmic]-0./ Input empty image at position 0 (1 image 0x0x0x0).`
>          `[gmic]-1./ Print image [0] = '[empty]'.                      `
>          `[0] = '[empty]':                                             `
>          `  size = (0,0,0,0) [0 b of floats].                          `
>          `  data = () [float].                                         `
>          `[gmic]-1./ End G'MIC interpreter.                            `

* Input an empty image
~~~
gmic -input 0 -print.
~~~
===
%% -input 0 expand_xy. 16 %%
 * Summon an image from the void: A roundabout way of making a 32 × 32 image. *
===

* Input an empty image, create a data area.
~~~
gmic -input 0 expand_xy. 16
~~~

# Command reference

===
"""
gmic -h input
"""
===
