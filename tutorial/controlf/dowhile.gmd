x# do…while (+)
%% x "mkdir -p img" %%
|![frontimage](images/do_elecamp.png)*Caution: Electrified 1911 Goudy Bookletter Ampersand. Please do not stand in any water puddles or other conductive liquids while following this tutorial. Thank you.*|The `-do` _<dowhile scope>_ `-while` block repeatly executes commands in the scope until the mathematical expression given as an argument to `-while` resolves to `False`. Execution then continues with the commands following `-while`. `-do`…`-while` follows a "perform, then test" course. With the conditional test at the bottom of the loop, the in-scope commands execute once even if the mathematical expression is initially `False`. For the "test, then perform" course, consider ''-for'' … ''-done.'' \n\nThe _<do while>_ scope need not be populated; it can serve as a placeholder for partially developed scripts.\n\nPrior to 2.6, `-while` would test file system references; that is no longer supported. Use the file system mathematical expressions `isfile()` or `isdir()` instead, which take file system paths as arguments and return `True` if the path identifies an existing file system object.
= examples
## Examples
|-`dowright:` \n   `-do` \n    `  -echo "You'll never take \` \n    `         me alive, Dudley  \` \n    `         Do-right!!!" ` \n   `-while bool(1)` |Snidely Whiplash won't shut up until `Ctrl-C` intervenes.\n\nCommands in the the _<do while>_ scope execute forever if the argument to `-while` remains `True`. In anticipation of this, build an 'escape hatch' with the ''-break'' command, usually in the scope of an ''-if'' … ''-fi'' block. Similarly, ''-continue'' terminates the current iteration and forces an immediate re-evaluation of `-while`'s conditional argument.
%% 300,300,1,1 cnt=5000 k,j={[w/2,h/2]} -do dk,dj={[0.05*(2*u-1)*w,0.05*(2*u-1)*h]} -eval ">begin(polygon(-2,"$k","$j","$k"+"$dk","$j"+"$dj",0.5,0xffffffff,255))" k,j={[$k+$dk,$j+$dj]} -if $k<0 k={$k+w} -elif $k>=w k={$k-w} -fi -if $j<0 j={$j+h} -elif $j>=h j={$j-h} -fi cnt={$cnt-1} -while $cnt n. 0,255 o. img/wander.png rm 0 %%
|![wanderaround](img/wander.png)*5000 steps of [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion) *|Usually, the commands constituting the body of the _<do while>_ scope have some direct or indirect effect on the condition given as an argument to `-while`. `-wanderaround,` listed below, draws specific counts of random-length, randomly oriented segments, end-to-end, on the currently selected image. It checks for boundary overshoot, wrapping on image-edge crossings, then decrements the current count. `-while` takes non-zero counts to be `True` and zero to be `False`. The body of the _<do while>_ scope decrements the count which `-while` tests and exits when the count goes to zero. 
===
~~~
wanderaround: -check "${1=50}>=0"
   k,j={[w/2,h/2]}
   cnt=$1
   -do
      # Draw one random segment
      dk,dj={[0.05*(2*u-1)*w,0.05*(2*u-1)*h]}
      -eval ">begin(
             polygon(-2,"$k","$j",
                     "$k"+"$dk",
                     "$j"+"$dj",
                     0.5,0xffffffff,255
                    )
                   )
            "
      # Step & do boundary check
      k,j={[$k+$dk,$j+$dj]}
      -if   $k<0   k={$k+w}
      -elif $k>=w  k={$k-w}
      -fi
      -if   $j<0   j={$j+h}
      -elif $j>=h  j={$j-h}
      -fi
      # Decrement count and test
      cnt={$cnt-1}
   -while $cnt
~~~
===
= lightningormayberivers
## Lightning Bolts, or Maybe Rivers
Two points which are distant "as the crow flies" may be effectively close at hand when connected by a smooth graded road. On the other hand, a point "nearby" in terms of flying crows is, as a practical matter, distant when there are mountains, oceans or implacibly fierce Corgis in the intervening regions. When factors other than spatial separation alter the effective distances between points, the ''-distance'' command can take a _cost map_ as an argument, which accounts for such factors and which alters how the `-distance` command records the separation between points and isovalues.

`-distance` takes a selected input image with some pixels set to a given isovalue and converts it to one where each pixel contains the measure to the nearest isovalue pixel - a _distance map_. The former isovalue pixels in the original input necessarily have a measure of zero in the distance map because they are zero pixels away from themselves. For all other pixels, `-distance` furnishes a distance measure from those pixels to the nearest isovalues. Beyond this basic operation, a separate, optional, cost map may assign a _traversal price_ to each input pixel. When such a map is in place, the distance measure written to each pixel in the distance map reflects the accumulated traversal prices of the intervening pixels between it and the nearest isovalue. This gives rise to a _minimal path_, that collection of intervening points which sum to the smallest cost. It is the effective "shortest distance" connecting two points, given that cost map and it need not be a straight line; it may look like a river or a lightning bolt.

= routingdirectivemaps
### Routing Return Maps
The ''-distance'' command produces a _routing return map_ when given a cost map and mode arguments of three or four (low- or high-connectivity Dijkstra metric functions, respectively. See ''-label''). The routing return map produces minimal paths connecting arbitrary points to isovalues.

For each pixel in the selected image, the routing return map contains a corresponding coded pixel, indicating the direction that some imagined cursor should go when taking one step on a minimal path to the nearest isovalue. When we place our imagined cursor anywhere in the routing return map, it reads such from the pixel it is sitting on. It is told one of two things:
|1.  |There are no directions to take — the current pixel corresponds to an isovalue in the input image.
|2.  |Take one step in the cardinal direction encoded in this routing return. From this point, it is the cheapest step available toward the nearest isovalue.

In this tutorial, we generally render this step on a separate canvas and, after some number of steps, have an image of the minimal path. That, in a nutshell, is the business of painting rivers, maybe, or lightning bolts, partcularly when `turbulence` or `-plasma` generates the cost map. 

Routing returns look like this:
===
= routingdirectschematic
![routingformat](images/routedir.svg)
*Routing Return Schematic*
===
It consists of three, two bit nibbles preceded by an unused nibble containing two unset (zero) bits. From the most significant bit to the least, the nibbles dictate z (depth), y (vertical), or x (horizontal) movement. In each nibble, the most significant bit flags forward (positive) movement; the least significant bit flags reverse (negative) movement.
|1. |Both nibbles may be unset. That indicates no movement in the given direction.
|2. |If the most significant nibble is set, one step, forward (positive) movement takes place.
|3. |If the least significant nibble is set, one step, reverse (negative) movement takes place.
|4. |Both nibbles cannot be set, as that conveys simultaneous forward and reverse movement.
Commencing from an arbitrary pixel with a non-zero routing return, the imagined cursor assesses the `x` and `y` nibbles and determines for each which of rules 1, 2, or 3 applies. Given that the return is non-zero, the cursor will step forward or backward in either the `x`, `y,` or combined cardinal directions: its first step on the minimal path brings it to one of eight neighboring pixels that is nearer, in a cost-wise sense, to the reference point. The cursor then performs the same assessment with the neighboring pixel. If that too is non-zero, the cursor steps further on, repeating its check-and-step routine until encountering a routing return that equals zero. In such a return, all nibbles are unset in forward and reverse directions. The cursor has arrived at a point corresponding to what was an isovalue in the original input. This permanently stops the cursor. Without a direction in which to move, it can no longer obtain new routing returns. The course it has traced from the starting pixel, wherever that may be, to the isovalue is the minimal cost path connecting the two pixels in the original input image. In a properly composed routing return map, zero-valued routing returns correspond to isovalues in the original and all other pixels have non-zero routing returns, so composed as to steer the imagined cursor toward the nearest isovalue.
= makingriverslightningbolts
### Making Lightning Bolts, Perhaps, or Maybe Rivers
The lightning bold crackling fiercely in the frontpiece stems from some 180 arbitrarily chosen points, from which minimal paths were traced to a single isovalue: a _reference point_. For the cost map, we rendered a mode 0 ''-turbulence'' pattern, further sharpened through inverse diffusion. We then set an isovalue of one in an otherwise black input image. Astute readers will recognize that we are playing a _Watershed Game,_ tracing the paths of so many droplets dribbling their ways down slope to the basin surrounding the reference point. This behavior follows readily from a turbulence-generated cost map. Mode 0 `-turbulence` forms discontinuous rilles which tend to snake in river- or lightning bolt-like ways. They are local minima, cheap pixels over which one may traverse.

Our game for river or lightning bolt emulation is straightforward. Harness `-distance` to generate a routing return map heavily influenced by a turbulence-generated cost map. Then, for a supply of a few hundred arbitrarily chosen pixels, trace their minimal paths to a single isovalue reference point. If we render these paths a dark gray and composite additively, then the more heavily traveled paths will tend to whites and light greys; less traveled ones will be darker.
%% m scripts/lightning.gmic -srand 56712 i 1024,1024,1,1 -turbulence. {round(0.65*w)},12,3,0,0 +r2dx. 300,5 sharpen. 50 n. 0,255 o. img/lght_00.png rm. i ../listmanip/images/ampersand.svg r. [-2],[-2],[-2],[-2],5,0 +store. ampersand -b. 11,1,0 -n. 0.3,1 *[-2,-1] sharpen. 50 +r2dx. 300,5 sharpen. 50 n. 0,255 o. img/lght_01.png rm. sqr. 100%,100%,100%,100% =. 1,400,430 -distance. 1,[-2],4 r2dx.. 300,5 sharpen.. 5 apply_gamma.. 2.2 n.. 0,255 o.. img/lght_02.png rm.. +r2dx. 300,5 sharpen. 50 n. 0,255 o. img/lght_03.png rm. paintbolts. {round(0.004375*wh,1,0)} +. 1 log. /. {log(iM)} r2dx. 300,5 sharpen. 2 n. 0,255 -k. -input 100%,100%,1,1 i $ampersand r2dx. 300,5 n. 0,1 f. lerp(1,0,i(x,y)) n. 0,216 a[-3,-2,-1] c -shift. 0,0,0,-50%,2,1 f. begin(wv=vector3(1/sqrt(3)));rot(wv,-75°)*I n. 0,255 o. img/lght_04.png rm 0 %%
= heightcost
#### Cost and Routing Return Maps
~~~
maketurbulence :
   -srand 56712
   -input 1024,1024,1,1
   -turbulence. {round(0.65*w)},12,3,0,0
~~~
= turbulence
|-![lightning_00](img/lght_00.png)*Turbulence*|The genesis of the frontpiece illustration is mode 0 [-turbulence](https://gmic.eu/oldtutorial/_turbulence.shtml). We base the cost and routing return map on this underlying rendering.\n\nAs noted in the [-plasma tutorial](https://gmic.eu/oldtutorial/_plasma.shtml), it is our wont to set a particular seed in G'MIC's random number generator (via ''-srand'') so that we can reproduce a particular pattern; what we have here may as well be called "Turbulence Pattern 56712".\n\nMode 0 turbulence employs the ''-abs'' command as a mixer; at each stage of its development, any zero-crossings are folded back into the positive region, generating numerous discontinuities — creases — both large and small. These emulate rilles and waterways. Being local minima, the rilles have low intensities; when we derive a cost map from this turbulence, rivers or lightning bolts will tend to follow these rilles. We revisit this idea downstream from here.\n\nWe render the turbulence so that it exhibits large-scale features, develop the pattern through 12 octaves and set a modest decay factor of three between each octave. While large-scale features are present, low-magnitude, small-scale features persist.
~~~
stampguide :
   -input images/ampersand.svg
   -resize [-2],[-2],[-2],[-2],5,0
   +store. ampersand
   -blur. 11,1,0
   -normalize. 0.3,1
   -mul[-2,-1]
   -sharpen. 50
~~~
= turbulencewithdepression
|-![lightning_01](img/lght_01.png)*Turbulence with Depression*|From this point forward, we modify the turbulence patterns in various ways to make our cost and routing return maps.\n\nThe first modification is impressing a Goudy 1911 Bookletter ampersand on the cost map, mainly because we are obsessed with this ampersand (but you knew that), and secondarily, we'd like to steer our lightning bolts so that they roughly trace parts of the ampersand's shape. Since we will trace the lightning bolts by the Watershed Game, we go about making a general depression in the turbulence in the shape of the ampersand; we blur the ampersand slightly to avoid abrupt drops into the basin.\n\nWe anticipate that as lightning bolts trace along minimal paths, those will thread through the lower elevation ampersand on the way to the isovalue. Once we have blurred and scaled the ampersand, we multiply it with the original turbulence, giving us the final form of our height map. Our cost map follows directly from sharpening and squaring operations. Sharpening tends to magnify fine detail, alternately, increasing or decreasing the values of out-of-bound pixels, driving them from the mean value of the image and towards its extremes. Squaring makes expensive (light colored) pixels even more expensive. In the larger scheme of things, we are making a cost map where minimal paths will meander a great deal, as we are creating pits and rises and other obstacles that mitigate against the straightforward progression of minimal paths to the isovalue. See the [-distance](https://gmic.eu/oldtutorial/_distance.shtml) tutorial, which provides further details on how cost maps give rise to the "price" of distances.
~~~
routingdirectives :
   -input 100%,100%,100%,100%
   -set. 1,400,430
   -distance. 1,[-2],4
   -remove..
~~~
= distancetoreference
|-![lightning_02](img/lght_02.png)*Distance to Reference*|With a cost map in hand, we harness the ''-distance'' command to make a second map, this of routing return directives. To this end, we need an image in which we may take measures of pixel distances to a reference point, so we can then derive costs. Forthwith, then, we conjure a black image from the aether and set a single reference point, a pixel with isovalue one. We plot the reference point at coordinates _[400, 430]_, on the e-loop of the ampersand, an arbitrary choice, but one almost in the center of the image and with just a few distinct approach directions. This input is then included in the `-distance` command's selection decorator.\n\n`-distance` replaces this input with a distance map. Each pixel in this new map holds the computed distance from that pixel to the reference point. The image of the reference point in the distance map necessarily has a computed distance of zero. All other pixels contain a positive measure, the cost map derived distances to the reference point. Should we care to look at the distance map sideways, pretending, say, to regard the distance measures as heights above a reference level, then the reference point could be seen as being at the bottom of the watershed, with all other points rising in altitude above that. Playful as it may be, this viewpoint has its uses in the Watershed Game.
= routingreturns
|-![lightning_03](img/lght_03.png)*Routing Returns at Six Kilometers — Too Small To See!*|For our purposes, this distance dataset is only a means toward another end, the the routing return map. `-distance` generates such when in mode 3 or 4. Both modes provide routing return maps and both use [Dijkstra Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) to find the least expensive path. Their difference is a subtle one. Mode 3 regards two rectangles sharing only one corner has having distinct, disconnected interiors — the low-connectivity setting. Mode 4 regards them as having common, connected interiors — the high-connectivty setting.\n\nWith a routing return map in hand, we can select any pixel as a starting point and plot the least expensive path to the reference point, our nascent lightning bolt. Since the `-distance` command was given our turbulence image with the ampersand depression — then the routing return map has "baked in" the traversal price for every pixel. From any pixel, excepting the reference point, there is always at least one "cheapest" direction, provided by the neighboring pixel with the lowest traversal price.
= routingdetail
|-![lightning_04](images/do_routing.png)*Routing Return Detail*|The conventional output from `-distance` is a [distance dataset](#distancetoreference) which furnishes point-wise distances of each pixel in the original image to the reference point. For the Great Watershed Game, we use the [routing return map](#routingdirectives) instead and throw away the distance dataset; it is not used to make lightning bolts.\n\nThe routing return map is a point-wise collection of control words, detailed [in the schematic](#routingdirectschematic), one corresponding to each pixel in the distance dataset. Given a pixel, the associated routing return conveys to an imagined cursor the least expensive direction it needs to step in order to move "closer" to the isovalue, in quotes because the routing return may shift the imagined cursor away from the isovalue, at least in terms of Euclidean distance. However, when `-distance` is furnished with a point-wise cost map, as we have done here, the "shortest distance" is the minimal path with the lowest cost sums, which likely is not the shortest distance by Euclidean measure.\n\n[On the left](#routingdetail), we have schematically reproduced the 9×9 pixel neighborhood around the reference point's image in the [routing return map](#routingdirectives). The numerals reprsent routing returns, each with three two-bit directional fields that collectively move an imagined cursor away from, or toward the isovalue, along each cardinal direction. Numerals 1, 5, 4, 6, 2, 10, 8 and 9 direct an imagined cursor, respectively, west, northwest, north, northeast, east, southeast, south or sourthwest. The special routing return 0 tells the cursor not to move; once a cursor is given such a directive it necessarily stops; it has been told to go nowhere so can never acquire another directive.\n\nThe `-distance` command computes these point-wise routing returns based on the cost map; in aggregate, these routing returns put an imagined cursor at a given point on a minimal path toward the nearest isovalue, one that accumulates the least cost along its length.
~~~
paintbolts: -check "isint(${1=200})>0"
   # Expect selected to be a routing map
   # generated by distance
   pcnt=$1
   -input 100%,100%,100%,100%
   -name. canvas
   -input $pcnt,2,1,1,(w*y+x)>=wh/2?round(u(h#-2-1),1):round(u(w#-2-1),1)
   -repeat $pcnt
      rdir=0
      kx={i(#-1,$>,0,0,0,0)}
      ky={i(#-1,$>,1,0,0,0)}
      -do
         -set[canvas] {i(#-2,$kx,$ky,0,0,0)+1},$kx,$ky,0,0
         rdir={i(#-3,$kx,$ky,0,0,0)}
         -if   {$rdir&1}
             kx={$kx-1}
         -elif {$rdir&2}
             kx={$kx+1}
         -fi
         -if   {$rdir&4}
             ky={$ky-1}
         -elif {$rdir&8}
             ky={$ky+1}
         -fi
      -while {$rdir>0}
   -done
   -keep[canvas]
~~~
= tracinglightningbolts
#### Tracing Lightning Bolts
|-![lightning_03](img/lght_04.png)*Lightning Rendered from Cheap Paths*|This brings us to the Watershed Game. The least expensive path from any pixel to the reference point arises from a "step-and-check" procedure. Our "path walker," `-paintbolts`, is built around a `-do … -while` block. An outer `-repeat` loop generates a random number of initial starting points from which we will trace minimal paths to the reference point. An inner `-do … -while` block traces one such path through a "step-and-check" procedure. Starting from an initial pixel [`$kx`, `$ky`], `-paintbolts` marks its first step on a separate output image. Then, referring to the routing return map for the coding of this pixel, determines its next move. This arises from a parsing of the coded directive, stored in `$rdir` and implemented through a pair of `-if…-elif…-fi` chains, one for the `x` cardinal direction and the other for the `y` cardinal direction. These two chains determine if there is a forward or reverse step in either cardinal direction. Being a two dimensional walker, `-paintbolts` has no chain for decoding the ±z cardinal direction. In any case, a non-negative directive will alter either `$kx` or `$ky` or both with forward or backward steps. Now on a new pixel, `-paintbolts` marks a new step and refers to the routing return map for the coding of the new pixel. And so on. And so forth. Eventually, if `-distance` created a sane routing return map, `$rdir` will obtain a zero value, which is the directive that translates to "No further steps." The path walker has arrived at the reference point and `-paintbolts` drops out of the `-do … -while` block, now to pick up a subsequent initial point for a new lightning bolt, should there be any are left.\n\nBecause of turbulence in the cost map, the least expensive path will be locally jagged, but it will converge on the reference pixel on a larger scale in a lightning bolt kind of way. You will note that one path is only faintly drawn, but many such paths will converge on the reference point from only a few directions and overlay one another to a considerable extent. The overlaid portions will seem very bright in the final rendering, as many paths contribute to the brightness. In aggregate, these paths will look like lightning bolts striking a common point.
 