# for (+)
%% x "mkdir -p img" 300,300,1,3 -noise 0.01,2 abs. 3,3,1,1,-0.125 =. 1,1,1 nm. neg 3,3,1,1,0.125 =. 1,1,1 nm. pos cnt=0 for abs(im#-3)<=0.95&&$cnt<1000 if $cnt%2 -convolve[-3] [pos],2,1 else -convolve[-3] [neg],2,1 fi cnt+=1 done keep... n. 0,255 o. img/forfun.png rm 0 %%
|![frontimage](images/forfun.png)|The `-for` _<loop scope>_ `-done` commands form a syntactical unit that repeatedly tests the [mathematical_expression](https://gmic.eu/reference/mathematical_expressions.html#top) argument given to `-for` and, if `True,` executes the in-scope commands, if any. The _<loop scope>_ need not be populated and is a placeholder when empty.\n\n`-for`…`-done` expresses a "test, then perform" pattern. With the conditional test at the top of the loop, the in-scope commands won't execute at all if `-for`'s argument first resolves to `False`. For a "perform, then test" pattern. consider ''-do'' … ''-while''.\n\nIf the contemplated conditional test entails simply incrementing or decrementing a counter, consider `-repeat`…`-done` instead, which has such counters built in. `-for`…`-done` is better for less straight forward circumstances, such reacting to changes in image conditions.\n\nPrior to 2.6, `-for` would test file system references. This is no longer supported. Use the file system mathematical expressions `isfile()` or `isdir()` instead.
%% 300,300,1,1 noise 0.01,2 abs. 3,3,1,1,-0.125 =. 1,1,1 for abs(im#-2)<0.72 -convolve.. [-1],2,1 done rm. n. 0,255 -o. img/convolve.png rm 0 %%
= examples
## Examples
One common use entails running a process until an image metric reaches a certain value that is deemed to be "done." With `-convolveuntil` we repeatly convolve-and-normalize an image containing unit impulses with an (approximate) [Airy disk](https://en.wikipedia.org/wiki/Airy_disk). This particular kernel amplifies differences in images. 
|![convolve](img/convolve.png)|` convolveuntil: ` \n `    -300,300,1,1            # Zero image with unit impulses.` \n `    -noise 0.01,2 ` \n `    -abs. ` \n `    -input 3,3,1,1,-0.125   # 3×3 Airy Disk for ` \n `    -set. 1,1,1             # repeated convolutions.` \n `    -for abs(im#-2)<=0.72   # Convolve until image` \n `       -convolve.. [-1],2,1 # minimum falls to -0.72.` \n `    -done ` \n `    -remove. ` \n `    -normalize. 0,255`

%% 256,256,1,1 gaussian. 64,64,0 threshold. 50% curvar={stats(#0)[3]} 1024,1,1,1 arycnt=0 for ($curvar>0.005)&&($arycnt<1024) b.. 1.5 curvar={stats(#0)[3]} =. $curvar,$arycnt,0,0 arycnt+=1 done display_graph. 300,300,3,0,0,1024,0,0.25,'blur count','variance' k. o. img/bgraph.png
rm 0 %%
Informally, [Variance](https://en.wikipedia.org/wiki/Variance) reflects the dispersion of observed values from an _expected value_, often, but not necessarily, their collective average — even more informally, their "sprawl". For example, if all observed values equal the expected value of the ensemble's average, then there is no dispersal and the variance is zero.

On the other extreme, where there is only black (0) or white (1), the expected value of the ensemble may be one half, but nary an observation occurs at such. The observations fall to one extreme or the other. In this contrived example, the variance is 0.25, the square of the mean. This stems from the typical way to compute the variance of an ensemble of observations:

===
$$

\operatorname{Var}(X) = \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2

$$
===

where µ is the _expected value_.

With a bit of squinting, a decrease in variance from an initial value could reflect the amount of blurring that has been applied to an image, with a blurred-beyond-any-hope-of-redemption coinciding with a variance of zero. `-bluruntil` produces a decay curve illustrating how a successively blurred image exhibits a decaying variance. The commandaccepts (1) a square image side length, (2) a number of times to blur an image (3) a target variance, (4) the sigma of a blurring kernel and other arguments one would pass to `-blur.` The command either stops when the specified variance decays to the appropriate level of image obliteration or the number of blur attempts reaches the number of trials we wish to attempt. These last two tests constitute the heart of a math expression which we present as an argument to `-for.`

|![blurgraph](img/bgraph.png)|` bluruntil: check "isint(${1=128})>0 && \ ` \n `                  isint(${1=128})>0 && \ ` \n `                  isnum(${3=1})>0   && \ ` \n `                  isnum(${4=1})>0   && \ ` \n `                  isbool(${5=1})    && \ ` \n `                  isbool(${6=0})" ` \n `   $=limit_ ` \n `   sigma={0.25*$limit_1} ` \n `   -input $limit_1,$limit_1,1,1 ` \n `   -name. blurbox ` \n `   -gaussian[blurbox] $sigma,$sigma,0 ` \n `   -threshold[blurbox] 50% ` \n `   curvar={stats(#0)[3]} ` \n `   -input $limit_2,1,1,1 ` \n `   -name. varlist ` \n `   arycnt=0 ` \n `   -for ($curvar>$limit_3)&&($arycnt<$limit_2) ` \n `      -blur[blurbox] $limit_4,$limit_5,$limit_6 ` \n `      curvar={stats(#0)[3]} ` \n `      -set[varlist] $curvar,$arycnt,0,0 ` \n `      arycnt+=1 ` \n `   -done ` \n `   -display_graph[varlist] 1200,600,1 ` 
