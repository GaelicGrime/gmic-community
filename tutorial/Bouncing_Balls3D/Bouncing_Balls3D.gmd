# 3D Bouncing Balls

## An example of G'MIC scripting:

The idea is to let people discover the possibilities of the \G'MIC language for creative coding and quick prototyping. We'll show how to write a \G'MIC script that generates the animation below, without going into all the details of the scriptâ€™s source code.

===
__â‡’ You donâ€™t need any prior knowledge of the  language to follow this tutorial!__

![teaser](images/teaser.gif)
*Fig.1. 3D balls bouncing on a sheet*
===

Perhaps this will make some people want to go deeper into its use for implementing custom image filters, who knows ? (despite the fact we all know the syntax looks a bit esoteric at a first glance! ðŸ™‚).

âš  At the end,  we wonâ€™t get exactly the same animation as above, but something really similar (I donâ€™t remember nor saved the exact parameters Iâ€™ve used at first to be honest!). âš 

Final code will be about **50 lines long**. Iâ€™ll \G'MIC use  version **2.9.6**, which is the most up-to-date version, at the time of writing this tutorial. Ready ? So, letâ€™s go for a \G'MIC ride!

---
## Step 1: Create a new G'MIC command.

G'MIC is an open-source framework for image processing, and has been thus designed as very versatile and extensible: Anyone is able to define their own custom commands that can be used afterwards in any G'MIC pipeline.

Thatâ€™s exactly what we will do here: write a single command dedicated to rendering this 3D bouncing ball animation. To do this, we first have to create a new text file 'tutorial.gmic', define and write the first lines of our new command, letâ€™s name it `tutorial3d`. This file looks like this:
~~~
# This is the content of the file `tutorial.gmic`.
#-------------------------------------------------
tutorial3d :
  echo "A cool G'MIC tutorial!"
~~~

That being done, the command-line tool 'gmic' is now able to execute our command, from the shell:
~~~
$ gmic tutorial.gmic tutorial3d
~~~
First we import the G'MIC command file 'tutorial.gmic', then we call our `tutorial3d` command (without arguments because our command doesnâ€™t require any).

And here is what we get:
~~~
$ gmic test.gmic tutorial3d
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input custom command file 'test.gmic' (1 new, total: 4202).
[gmic]-0./tutorial3d/ A cool G'MIC tutorial!
[gmic]-0./ End G'MIC interpreter.
~~~
By default, 'gmic' is quite verbose, so it outputs what it does on the standard error, with some info about the current command scope for each action. Here, when evaluating command `tutorial3d`, it prints the message passed as an argument to the `echo` command.
Now that our command is set up, letâ€™s try to do more complicated things ðŸ™‚.

---
## Step 2: Create the checkerboard texture.

One of the thing we have to do is to create the checkerboard texture that will be mapped onto the 3D sheet. We need to render a small color image, e.g. with resolution '128x128' (will be enough for our purpose) that represents a white/red checkerboard.
There are several ways to do this. Here, we are looking for a simple checkerboard (no rotations, constant cell size, only 2 distinct colors), thus we can render it by using a simple math formula.
In this case, I propose to use the ''-input'' command, like this:
~~~
tutorial3d :

  # Init texture image. <- This is a comment line :)
  input 128,128,1,3,"xor(x,y)%16<8?[ 255,0,0 ]:[ 255,255,255 ]"
  # ^ ^ ^ ^
  # width (128), height (128), depth (1), nb_channels (3 = RGB)
~~~

#### A few explanations:

In G'MIC, any image is specified by its 4 dimensions : 'width' (number of columns), 'height' (number of rows), 'depth' (number of slices, = `1` for 2D images), and 'spectrum' (number of channels, = `3` for RGB color images, and = `4` for RGBA). Pixel values are always 'float'-valued and there are no limitations on the size along each dimension (except the available memory required to store the image). This way, many different types of images can be represented (e.g. the number of channels can be of any value, like `64` or `128`, and 3D volumetric dense arrays can be managed as well).
Here, `input 128,128,1,3` means we want to create a 2D image of RGB colors with resolution '128x128' (itâ€™s one of the possible list of arguments accepted by command ''-input'').

Also, when creating a new image with ''-input'', we have the possibility to specify a **formula** used to initialize the values of the image pixels (as an optional last argument). Without formula specified, all pixel values are set to `0` by default. The formula can be as complex as you want (G'MICâ€™s mathematical evaluator has actually quite advanced features). Itâ€™s good to know that the math evaluator has pre-defined variables that are useful when writing math expressions (e.g., `x` and `y`, the two variables corresponding to the 2D coordinates for each pixel to be evaluated).

The formula we wrote in our example looks a bit tricky, but you can verify by yourself, `xor(x,y)%16<8` is a condition that evaluates as `0` or `1`, following a checkerboard pattern (with tiles of size '8x8'). So, depending on the result of this condition, we fill the image pixel with the 3-components vectors `[255,0,0]` (pure red in RGB) or `[255,255,255]` (pure white in RGB).
Note that there are not many different types of data that can be manipulated in the mathematical evaluator, apart from real numbers and vectors (this latter type includes complex numbers and strings as well), the latter bein surrounded by brackets `[]`.

Now, if we type `$ gmic tutorial.gmic tutorial3d` on the terminal, we get this nice checkboard texture displaying on the screen:
===
%%128,128,1,3,"xor(x,y)%16<8?[ 255,0,0 ]:[ 255,255,255 ]"%%
*Fig.2. Checkerboard texture.*
===

Letâ€™s name it 'texture' (with command ''-name'', a.k.a `nm`), and letâ€™s remove the explicit call to the ''-input'' command (because ''-input'' is actually the only command whose shortcut is the empty string!), and we have the first significant line of our script ready:
~~~
tutorial3d :

  # Init texture image.
  128,128,1,3,"xor(x,y)%16<8?[255,0,0]:[255,255,255]" nm. texture
~~~
