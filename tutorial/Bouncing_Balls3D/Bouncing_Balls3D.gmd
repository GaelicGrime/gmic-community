# 3D Bouncing Balls

## An example of G'MIC scripting:

The idea is to let people discover the possibilities of the \G'MIC language for creative coding and quick prototyping. We'll show how to write a \G'MIC script that generates the animation below, without going into all the details of the scriptâ€™s source code.

===
__â‡’ You donâ€™t need any prior knowledge of the  language to follow this tutorial!__

![teaser](images/teaser.gif)
*Fig.1. 3D balls bouncing on a sheet*
===

Perhaps this will make some people want to go deeper into its use for implementing custom image filters, who knows ? (despite the fact we all know the syntax looks a bit esoteric at a first glance! ðŸ™‚).

âš  At the end,  we wonâ€™t get exactly the same animation as above, but something really similar (I donâ€™t remember nor saved the exact parameters Iâ€™ve used at first to be honest!). âš 

Final code will be about **50 lines long**. Iâ€™ll \G'MIC use  version **2.9.6**, which is the most up-to-date version, at the time of writing this tutorial. Ready ? So, letâ€™s go for a \G'MIC ride!

---
## Step 1: Create a new G'MIC command.

G'MIC is an open-source framework for image processing, and has been thus designed as very versatile and extensible: Anyone is able to define their own custom commands that can be used afterwards in any G'MIC pipeline.

Thatâ€™s exactly what we will do here: write a single command dedicated to rendering this 3D bouncing ball animation. To do this, we first have to create a new text file 'tutorial.gmic', define and write the first lines of our new command, letâ€™s name it `tutorial3d`. This file looks like this:
~~~
# This is the content of the file `tutorial.gmic`.
#-------------------------------------------------
tutorial3d :
  echo "A cool G'MIC tutorial!"
~~~

That being done, the command-line tool 'gmic' is now able to execute our command, from the shell:
~~~
$ gmic tutorial.gmic tutorial3d
~~~
First we import the G'MIC command file 'tutorial.gmic', then we call our `tutorial3d` command (without arguments because our command doesnâ€™t require any).

And here is what we get:
~~~
$ gmic test.gmic tutorial3d
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input custom command file 'test.gmic' (1 new, total: 4202).
[gmic]-0./tutorial3d/ A cool G'MIC tutorial!
[gmic]-0./ End G'MIC interpreter.
~~~
By default, 'gmic' is quite verbose, so it outputs what it does on the standard error, with some info about the current command scope for each action. Here, when evaluating command `tutorial3d`, it prints the message passed as an argument to the `echo` command.
Now that our command is set up, letâ€™s try to do more complicated things ðŸ™‚.

---
## Step 2: Create the checkerboard texture.

One of the thing we have to do is to create the checkerboard texture that will be mapped onto the 3D sheet. We need to render a small color image, e.g. with resolution '128x128' (will be enough for our purpose) that represents a white/red checkerboard.
There are several ways to do this. Here, we are looking for a simple checkerboard (no rotations, constant cell size, only 2 distinct colors), thus we can render it by using a simple math formula.
In this case, I propose to use the ''-input'' command, like this:
~~~
tutorial3d :

  # Init texture image. <- This is a comment line :)
  input 128,128,1,3,"xor(x,y)%16<8?[ 255,0,0 ]:[ 255,255,255 ]"
  # ^ ^ ^ ^
  # width (128), height (128), depth (1), nb_channels (3 = RGB)
~~~

#### A few explanations:

In G'MIC, any image is specified by its 4 dimensions : 'width' (number of columns), 'height' (number of rows), 'depth' (number of slices, = `1` for 2D images), and 'spectrum' (number of channels, = `3` for RGB color images, and = `4` for RGBA). Pixel values are always 'float'-valued and there are no limitations on the size along each dimension (except the available memory required to store the image). This way, many different types of images can be represented (e.g. the number of channels can be of any value, like `64` or `128`, and 3D volumetric dense arrays can be managed as well).
Here, `input 128,128,1,3` means we want to create a 2D image of RGB colors with resolution '128x128' (itâ€™s one of the possible list of arguments accepted by command ''-input'').

Also, when creating a new image with ''-input'', we have the possibility to specify a **formula** used to initialize the values of the image pixels (as an optional last argument). Without formula specified, all pixel values are set to `0` by default. The formula can be as complex as you want (G'MICâ€™s mathematical evaluator has actually quite advanced features). Itâ€™s good to know that the math evaluator has pre-defined variables that are useful when writing math expressions (e.g., `x` and `y`, the two variables corresponding to the 2D coordinates for each pixel to be evaluated).

The formula we wrote in our example looks a bit tricky, but you can verify by yourself, `xor(x,y)%16<8` is a condition that evaluates as `0` or `1`, following a checkerboard pattern (with tiles of size '8x8'). So, depending on the result of this condition, we fill the image pixel with the 3-components vectors `[255,0,0]` (pure red in RGB) or `[255,255,255]` (pure white in RGB).
Note that there are not many different types of data that can be manipulated in the mathematical evaluator, apart from real numbers and vectors (this latter type includes complex numbers and strings as well), the latter bein surrounded by brackets `[]`.

Now, if we type `$ gmic tutorial.gmic tutorial3d` on the terminal, we get this nice checkboard texture displaying on the screen:
===
%%128,128,1,3,"xor(x,y)%16<8?[ 255,0,0 ]:[ 255,255,255 ]"%%
*Fig.2. Checkerboard texture.*
===

Letâ€™s name it 'texture' (with command ''-name'', a.k.a `nm`), and letâ€™s remove the explicit call to the ''-input'' command (because ''-input'' is actually the only command whose shortcut is the empty string!), and we have the first significant line of our script ready:
~~~
tutorial3d :

  # Init texture image.
  128,128,1,3,"xor(x,y)%16<8?[255,0,0]:[255,255,255]" nm. texture
~~~

A few words about the '.' added as a suffix to the command ''-name'' (aka `nm`):

In G'MIC, every newly created image becomes a part of a *globally-managed list of images*, and after the execution of the ''-input'' command, our texture image becomes a new item of this list. Each image in the list has an *index* (starting from '0') and an (optional) *name*. Our texture image is the very first image we created, so it can now be referred as image '[0]'. Negative indices can be used: '[-1]' for the last image of the list, '[-2]' for the penultimate one, etcâ€¦ Thus, our texture image can be also referred as '[-1]' (itâ€™s the first as well as the last image of the list).

A command in G'MIC is able to act on one or several images at a time. A commands accepts a '[selection]' suffix, to tell on which image(s) it must be applied. In our case, command ''-name'' has to modify the name of the texture image, so we could write `name[0]` or `name[-1]`. The latter selection is so commonly used that it has its own shortcut . (which stands for '[-1]'). That explains the use of `nm.` which is actually a double-shortcut for `name[-1]`.
Note that in this case, specifying a selection was not really needed. When no '[selection]' is given, a command processes all images available in the list, and here we have only a single texture image already in the list. But itâ€™s good to pick up some good habits ðŸ™‚.

Once our texture image has been named as 'texture', we can refer it by '[texture]' (in addition to '[0]' and '[-1]'). Giving it an explicit name will actually help us afterwards to not worry about the index it has in the list of images. As we will add more images, '[-1]' will not be valid anymore in the next steps.

---
## Step 3: Create the background image.

We write a similar line of code to create our background image, which is intended be a vertical color gradient:
~~~
tutorial3d :

  # Init texture image and background.
  128,128,1,3,"xor(x,y)%16<8?[255,0,0]:[255,255,255]" nm. texture
  512,512,1,3,"lerp([ 32,128,99 ],[ 0,0,16 ],y/(h-1))" nm. background
~~~

The added line defines a '512x512' color image, which is the intended size of our rendered animation frames. Here the formula makes use of the pre-defined math function 'lerp(a,b,t)' which is actually a built-in equivalent to `a*(1-t) + b*t`, where 'a' and 'b' are the two values we want to interpolate (here, 3-components vectors) that define our color gradient. The interpolation parameter 't' is equal to 'y/(h-1)' and ranges from `0` to `1` from the top to the bottom of the image.

Now, our list of images contains two images '[texture]' (i.e. '[0]') and '[background]' (i.e. '[1]'), which are:
===
%% images/content_step3.jpg r2dx 500%%
===
Not a bad start!

---
## Step 4: Create a 3D colored ball.

G'MIC has basic 3D rendering possibilities - that are not extraordinary - but sufficient for the type of animation we aim to create. 3D rendering in G'MIC mainly relies on the command ''-object3d'' (shortcut `j3d`) that draws/renders a 3D meshed object on a 2D image.

A 3D mesh is actually stored as an image itself in the image list, just as any other images. A 3D mesh is a 1-column image whose pixel values give all required information about its vertex positions, types of primitives, colors, textures, and everything required to render the 3D object properly. While such images can be created from scratch, itâ€™s usually convenient to use one of the several commands available in G'MIC, to create common 3D primitives (e.g. ''-sphere3d'', ''-box3d'', ''-torus3d'',â€¦), set their colors and opacities (''-color3d'', ''-opacity3d''), merges 3D objects together (''-add3d''), etc. (the procedural 3D object creation can always lead to [nice things](https://www.youtube.com/watch?v=3iqyJ4qSheU)).

For now, we just need a 3D sphere that will be our first bouncing ball (others will be added later), so we call command ''-sphere3d'':
~~~
tutorial3d :

  # Init images and display window and 3D ball.
  128,128,1,3,"xor(x,y)%16<8?[ 255,0,0 ]:[ 255,255,255 ]" nm. texture
  512,512,1,3,"lerp([ 32,128,99 ],[ 0,0,16 ],y/(h-1))" nm. background
  sphere3d 10 col3d. 255,0,255 nm. ball3d
~~~

Command `sphere3d 10` inserts a new 3D meshed sphere with radius `10` at the end of the image list (as a new image '[2]'). Command `col3d 255,0,255` sets the primitive colors to magenta. Finally, command `nm. ball3d` sets a name to this image, exactly as we did for the previous images.

There are two ways of visualizing image '[ball3d]':