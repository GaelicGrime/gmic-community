# rbf
%% x "mkdir -p img" %%

|![frontimage](images/amp.mp4)|Given a sparse sampling, ''-rbf'' reconstructs an approximation of an image from a weighted set of [radial basis functions](https://en.wikipedia.org/wiki/Radial_basis_function), $$ \mathit{w}\varphi(\|\mathbf{r}\|) $$, each scaling an associated sample. `-rbf` finds the weights from a [least squares](https://en.wikipedia.org/wiki/Least_squares) fitting; the solution interpolates the samples and fits estimates for the remainder of the image. `-rbf` can reconstruct approximations from sampling rates of 0.1% — 0.5%, or about 1,000 pixels from a 1000 × 1000 image.\n\nAmong other tasks, G'MIC uses `-rbf` to compress color look up tables (CLUTs), where a sparse sampling of the original provides a compact representation. The behavior of the reconstructed CLUT is often difficult to distinguish from the original.

Given two numerals, 3 and 7, one could guess at an in-between value of 5. On what basis does that sit? Well — none, really. It stems from some heuristic notion that, knowing nothing else about a pair of extremes, the in-betweens are taken to be as likely as anything else. Thus goes the art of reconstruction: given (a very few) hints, imagine the whole as so many averages. The technique here entails using _basis functions_, a kind of simple-to-compute template that we scale, slide around and apply to our very few samples to estimate what goes on in between them.

Radial basis functions (RBFs) are one such type, so-called because these functions, $$ \varphi(\|\mathbf{r}\|) $$ take only a radius _r_ and return a "relative contribution" factor. That factor reflects what a known sample contributes to an approximation at the radial distance _r_. This radius is itself a proxy for a difference that we take between two locations: the place where we are making our assessment, __x__, and the place where the sample has been "observed" __c__. A suitably scaled set of RBFs $$ \mathit{w_i}\varphi(\|\mathbf{x_i} - \mathbf{c_i}\|) $$ can approximate an entire image through a small set of samples so long as some loss is acceptable.

''-rbf'', given a set of samples, returns an approximate _range_ image. The samples may be drawn from one, two or three dimensional spaces and the range image has a like number. We can take an inconveniently large data set, such as a color look-up table (CLUT), and save select samples, these consuming a fraction of the storage of the original. Later on, we could reconstruct the CLUT from the samples and obtain something that _almost_ matches the original. _Is_ it the original? No. Does it work _like_ the original? It could be a pretty fair dinkum, with an adroitness to the sampling and an apt choice of RBFs; that is a deep topic upon the edge of which we teeter. For safety's sake, let's assume a sampling fair and RBFs robust. This brings us to particulars:

|1.  |We obtain samples — "spot-checks" — for an otherwise unknown image.
|2.  |`-rbf` plots approximations into one, two or three dimensional images: the _range_.
|3.  |Arguments to `-rbf` quantify the range for `·`: `x, y` or `z`. `d·` arguments specify range dimensions and lengths; these are required. `·0` arguments specify origin offsets; their absences imply zero offsets. `·1` arguments specifies the dimensions and lengths of the sample space; their absences imply that the sample and range spaces have equal dimensions and that scaling is 1:1. A final, optional string is taken to be a math expression and defines a custom RBF. Its absence implies the default RBF, the _thin plate spline_, described further on.
|4.  |The images referenced in `-rbf`'s selection decorator are one dimensional vectors encoding samples. Each pixel encodes samples in spatial coordinate-sample value order; two coordinates and three values codify the position and color of an RGB sample, for example. Each datum occupies separate channels. `-rbf` separates coordinate from value channels by determining the number of dimensions of the output range. This arises from particular argument signatures:
|      a.|one, three or four arguments: one dimensional ranges. Signatures may consist of 1 argument: Only the length of the range: `dx`. They may consist of 3 arguments: Range length with origin offset `x0` and the sample space dimensional length `x1`; `dx:x1` sets scaling from range to sample space. They may consist of 4 arguments: Those before plus a custom RBF, written as a math expression.
|      b.|two, six and seven arguments: two dimensional ranges. Signatures may consist of 2 arguments: Only the length of the range in `dx` and `dy`. They may consist of 6 arguments: Range length in `dx` and `dy`, origin offsets, `x0` and `y0` and the sample space dimensional lengths `x1` and `y1`. They may consist of 7 arguments: Those before plus a custom RBF, a math expression. 
|      c.|nine and ten arguments: three dimensional ranges. Signatures may consist of 9 arguments: The length of the range in  `dx`, `dy` and `dz`, origin offsets `x0`, `y0` and `z0` and the sample space dimensional lengths `x1`, `y1` and `z1`. They may consist of 10 arguments: Those before plus a custom RBF, a math expression.
|5.  |"Decompressing" a sparse set of samples into an approximation range entail finding weights for each of the RBF's, so that associated samples may be appropriately scaled. This is taken as a least squares problem; G'MIC composes a design matrix ___D___ by taking the absolute values of pairwise differences among the given samples and evaluating these with the chosen RBF. The design matrix which arises from this exercise is symmetric, the lower diagonal mirroring the upper. A linear least squares approach solves for the weights of the RBFs:  

===
$$
\mathbf(D) = 
\begin{bmatrix}
\varphi(\|\mathbf{x}_1 - \mathbf{x}_1\|) & \varphi(\|\mathbf{x}_2 - \mathbf{x}_1\|) & \dots & \varphi(\|\mathbf{x}_n - \mathbf{x}_1\|) \\
\varphi(\|\mathbf{x}_1 - \mathbf{x}_2\|) & \varphi(\|\mathbf{x}_2 - \mathbf{x}_2\|) & \dots & \varphi(\|\mathbf{x}_n - \mathbf{x}_2\|) \\
\vdots & \vdots & \ddots & \vdots \\
\varphi(\|\mathbf{x}_1 - \mathbf{x}_n\|) & \varphi(\|\mathbf{x}_2 - \mathbf{x}_n\|) & \dots & \varphi(\|\mathbf{x}_n - \mathbf{x}_n\|) \\
\end{bmatrix}
\begin{bmatrix}
\mathbf{w}_1 \\ \mathbf{w}_2 \\ \vdots \\ \mathbf{w}_n
\end{bmatrix} = 
\begin{bmatrix}
\mathbf{s}_1 \\ \mathbf{s}_2 \\ \vdots \\ \mathbf{s}_n
\end{bmatrix}
$$
===
With weights found, `-rbf` performs its reconstruction, visiting every pixel in the range and estimating its magnitude from the weighted contributions of the given samples. The particular RBF chosen can have considerable influence on the character of these estimates, as shown in the following one dimensional reconstruction, all using the same six samples, but different RBFs:
%% (3,25,100,190,240,252^3,30,75,120,255,4) nm. points +rbf. 256,0,255 nm. data 2068,532,1,3,[255,255,255] nm. canvas +graph[canvas] [data],2,0,389,-71,255,0xffffffff,230,100,0 erode_circ. 3 rm[data] blend[-2] [-1],multiply f. [255,255,255] +rbf[points] 256,0,255,"r" nm. data graph[-2] [data],2,0,389,-71,255,0xffffffff,200,30,240 erode_circ[-2] 3 rm[data] blend[-2] [-1],multiply f. [255,255,255] +rbf[points] 256,0,255,"exp(-r^2)" nm. data graph[-2] [data],2,0,389,-71,255,0xffffffff,40,100,0 erode_circ[-2] 3 rm[data] blend[-2] [-1],multiply f. [255,255,255] +rbf[points] 256,0,255,"exp(-(0.04*r)^2)" nm. data graph[-2] [data],2,0,389,-71,255,0xffffffff,120,220,0 erode_circ[-2] 3 rm[data] blend[-2] [-1],multiply rm[-1] eval ">begin(dv=crop(#0,0,0,w#0,h#0));for(kz=0,kz<w#0,kz=kz+1,px=8.12*dv[kz];py=145+0.575*((h#-1)-2*dv[w#0+kz]);ellipse(#-1,px,py,7,7,0,127,[0,120,240]);ellipse(#-1,px,py,-7,-7,0,255,0xffffffff,[0,0,0]))" -grid[-1] 16.67%,8.32%,5,5,255,0xcccccccc,[100,100,100] rm[0] r2dx. 50%,5 o. img/graph.png rm 0 %%
===
 ![basisfunctions](img/graph.png)
  *Various Radial Basis Functions recreate 1-D estimated functions from six sample points.* 
===
|-1.  |Blue dots|  | Six sample points
|2.  |Purple| $$ r $$ | [Lerps](https://en.wikipedia.org/wiki/Linear_interpolation) the samples.
|3.  |Olive | $$ e^{-r^2} $$ | Unscaled Gaussians.
|4.  |Light Green|$$ e^{-{\epsilon}r^2} $$ | Scaled Gaussians. The frontpiece animation illustrates a progression of ε from 1.0 → 0.01.
|5.  |Orange| $$ {r^2}\ln(1\times{10^{-5}}+r) $$ | Thin plate spline, the default radial basis function. Its behavior between samples is reminiscent of spring steel strips.

= examples
## Examples

%% (253,255,253,255,253,255^253,253,255,255,257,257,257^235,28,235,28,235,28^184,41,184,41,184,41^28,239,28,239,28,239) rbf. 512,512 cut. {-2^15},{2^15} -n. 0,255



# Command Reference

===
"""
gmic -h rbf
"""
===
= notes
## Notes
|-`dx`,`dy`,`dz`|Sets the output range, in pixels. `dx`, in isolation, implies a one dimensional output range. `dx`,`dy` implies a two dimensional output range. `dx`,`dy`,`dz` implis a three dimensional output range. Must be specified (no defaults).
|-`x0`,`y0`,`z0`|__Origin__: Sets what output coordinate, `·0`, corresponds to input origin `0`. Provide as many origin coordinates `·0` as there are output ranges `d·`. Defaults to 0.
|-`x1`,`y1`,`z1`|__Scaling__: `d·:·1`. Sets what input range, `·1`, corresponds to output range `d·`  Provide as many input ranges `·1` as there are output ranges `d·`. Set ·1 = d· for 1:1 scaling from input to output. Set ·1 = 2*d· for 50% downscaling from input to output. Defaults to `d· – 1`.
| `phi(r)`\n(_math expression_) | Set the radial basis function. The default, `r^2*log(1e-5+r)` provides the [thin plate spline](https://en.wikipedia.org/wiki/Thin_plate_spline). The math expression recognizes the symbol `r` (radius) as representing the Euclidean distance  __xy__ — __c__ between image points __xy__ and samples __c__. During evaluation of the basis function, G'MIC's math parser substitutes for `r`, wherever it may appear in the expression, the Euclidean distance. Other expressions may be provided, over-riding the default. Ensure that the math expression is written in terms of just one variable, `r`.
